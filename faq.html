<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Kaitai Struct: FAQ</title>
<link rel="stylesheet" href="./styles/colony.css">
</head>
<body class="article">
    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li class=""><a href="http://kaitai.io/#what-is-it">What is it?</a></li>
                    <li class=""><a href="http://kaitai.io/#quick-start">Quick Start</a></li>
                    <li class=""><a href="http://kaitai.io/#download">Download</a></li>
                    <li class=""><a href="http://kaitai.io/#format-gallery">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://kaitai.io/repl/index.html">Try it</a></li>
                    <li class="active"><a href="index.html">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<div id="header">
<h1>Kaitai Struct: FAQ</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_general">General</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_is_it_fast">Is it fast?</h3>
<div class="paragraph">
<p>Yes, pretty much. Kaitai Struct is not a runtime interpreter, but a compiler — thus it imposes no additional runtime performance penalty. Code that it generates is about as fast as one can write in a particular language to parse a certain data format.</p>
</div>
<div class="paragraph">
<p>That said, note that Kaitai Struct is all about producing a clean API for parsing binary data. That means that general usage plan is:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create object (structure) in memory and parse stream into it</p>
</li>
<li>
<p>Use it via API afterwards</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This pattern is generally a good fit for most applications, but for some types of workloads you might want a completely different approach: acting as soon as every particular chunk of data stream is parsed based on that chunk only. This calls for an event-based parsing model (i.e. you define some code that will be executed on each particular state of the parser) and thus, probably, you&#8217;ll find that other tools like [parser combinators](<a href="https://en.wikipedia.org/wiki/Parser_combinator" class="bare">https://en.wikipedia.org/wiki/Parser_combinator</a>), finite-state machine generators or even plain [lexer/parser generators](<a href="https://en.wikipedia.org/wiki/Comparison_of_parser_generators" class="bare">https://en.wikipedia.org/wiki/Comparison_of_parser_generators</a>) will suit that approach better than Kaitai Struct. In these cases, Kaitai Struct&#8217;s approach "read-then-use" <strong>might</strong> be slower than event-based "read-and-act-simultaneously" approach.</p>
</div>
</div>
<div class="sect2">
<h3 id="_is_output_of_ks_readable">Is output of KS readable?</h3>
<div class="paragraph">
<p>Yes, Kaitai Struct compiler generates very human-readable files, which can be examined with naked eye, debugged if needed, etc. For example, reading a two-byte signed little-endian integer is usually translated into something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">field = _io.readS2Le();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_does_it_support_writing_generation_serialization_of_structures_into_stream_or_only_reading_parsing_deserialization_of_structures_from_the_stream">Does it support writing (generation, serialization) of structures into stream, or only reading (parsing, deserialization) of structures from the stream?</h3>
<div class="paragraph">
<p>So far Kaitai Struct focuses on reading (parsing) only. There are plans to support writing, but don&#8217;t hold your breath for it — it&#8217;s a pretty major change and it&#8217;ll probably happen after 1.x.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_does_it_compare_to">How does it compare to &#8230;&#8203;</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="__google_protocol_buffers_asn_1_apache_thrift_apache_avro_bson_etc">&#8230;&#8203; [Google Protocol Buffers], [ASN.1], [Apache Thrift], [Apache Avro], [BSON], etc?</h3>
<div class="paragraph">
<p>They&#8217;re completely different. Projects mentioned are actually different serialization specifications that map existing data into some sort of extensible binary stream, usually for easy transmission / interchange. Binary representation is driven by the data and encoded according to particular standard of a given protocol, which usually has a fixed representation for integers, for strings, for arrays, for dictionaries, etc. Most of these project allow generated formats to be automatically extensibile, carry versioning information, automatically embed typing information of some sort.</p>
</div>
<div class="paragraph">
<p>KS approaches from the other end: given some sort of existing (or planned) binary representation, build a set of classes that the data inside this representation can be held in and build a parser for it. You can&#8217;t read an arbitrary binary format (like, for example, <code>.gif</code>, <code>.wav</code>, or <code>.pdf</code>).</p>
</div>
<div class="paragraph">
<p>[Google Protocol Buffers]: <a href="https://github.com/google/protobuf" class="bare">https://github.com/google/protobuf</a>
[ASN.1]: <a href="https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One" class="bare">https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One</a>
[Apache Thrift]: <a href="https://thrift.apache.org/" class="bare">https://thrift.apache.org/</a>
[Apache Avro]: <a href="https://avro.apache.org/" class="bare">https://avro.apache.org/</a>
[BSON]: <a href="http://bsonspec.org/" class="bare">http://bsonspec.org/</a></p>
</div>
</div>
<div class="sect2">
<h3 id="__cap_n_proto">&#8230;&#8203; [Cap&#8217;N Proto]?</h3>
<div class="paragraph">
<p>Most of the arguments from the previous answer (for [Google Protocol Buffers], [ASN.1], [Apache Thrift], [Apache Avro], [BSON]) apply here as well. Cap&#8217;N Proto is not a tool for reading or writing arbitrary formats. Instead, it uses a couple of clever tricks to make serialization and deserialization more efficient (casting binary structures as blocks, not assigning individual fields), but, essentially, it emphasizes content, and offers very limited control over serialization format.</p>
</div>
<div class="paragraph">
<p>In theory, [Cap&#8217;N Proto encoding scheme](<a href="https://capnproto.org/encoding.html" class="bare">https://capnproto.org/encoding.html</a>) is well documented and can be implemented in .ksy to parse Cap&#8217;N Proto encoded messages.</p>
</div>
<div class="paragraph">
<p>[Cap&#8217;N Proto]: <a href="https://capnproto.org/" class="bare">https://capnproto.org/</a></p>
</div>
</div>
<div class="sect2">
<h3 id="__gnu_bison_yacc_lex_flex_etc">&#8230;&#8203; [GNU Bison], [Yacc], [Lex], [Flex], etc?</h3>
<div class="paragraph">
<p>All these tools actually work on parsing text (most usually, source code) using context-free grammars. The core problem they solve is ambiguity of whatever was read. For example, a single letter <code>a</code> might be part of string literal, part of an identifier, part of a tag name, etc. In most cases, parsers that they generate have a concept of <strong>state</strong> and a fairly complex ruleset to change states. On the other hand, binary files are usually structured in a non-ambiguous way: there&#8217;s no need to do complex backtracking, re-interpreting everything in a different fashion just because we&#8217;ve encountered something near the end of the file. There&#8217;s usually no <strong>state</strong> beyond the pointer in the stream and pointer the code that does parsing.</p>
</div>
<div class="paragraph">
<p>[GNU Bison]: <a href="https://www.gnu.org/software/bison/" class="bare">https://www.gnu.org/software/bison/</a>
[Yacc]: <a href="https://en.wikipedia.org/wiki/Yacc" class="bare">https://en.wikipedia.org/wiki/Yacc</a>
[Lex]: <a href="https://en.wikipedia.org/wiki/Lex_(software" class="bare">https://en.wikipedia.org/wiki/Lex_(software</a>)
[Flex]: <a href="http://flex.sourceforge.net/" class="bare">http://flex.sourceforge.net/</a></p>
</div>
</div>
<div class="sect2">
<h3 id="__sweetscape_010_editor_synalysis_hexinator_okteta_ibored">&#8230;&#8203; [SweetScape 010 Editor], [Synalysis], [Hexinator], [Okteta], [iBored]?</h3>
<div class="paragraph">
<p>All these tools are advanced hex editors with some sort of <strong>template language</strong>, which is actually pretty close to <code>.ksy</code> language. One major difference is that <code>.ksy</code> files, unlike per-editor templates, can be compiled right into parser source code in any supported language.</p>
</div>
<div class="paragraph">
<p>[SweetScape 010 Editor]: <a href="http://www.sweetscape.com/010editor/" class="bare">http://www.sweetscape.com/010editor/</a>
[Synalysis]: <a href="http://www.synalysis.net/" class="bare">http://www.synalysis.net/</a>
[Hexinator]: <a href="https://hexinator.com/" class="bare">https://hexinator.com/</a>
[Okteta]: <a href="https://docs.kde.org/stable5/en/kdesdk/okteta/tools-structures.html" class="bare">https://docs.kde.org/stable5/en/kdesdk/okteta/tools-structures.html</a>
[iBored]: <a href="http://apps.tempel.org/iBored/" class="bare">http://apps.tempel.org/iBored/</a></p>
</div>
</div>
<div class="sect2">
<h3 id="__preon">&#8230;&#8203; [Preon]?</h3>
<div class="ulist">
<ul>
<li>
<p>Both Preon and KS are declarative</p>
</li>
<li>
<p>Preon is Java-only library, KS is a cross-language tool</p>
</li>
<li>
<p>Preon&#8217;s data structure definitions are done as annotations inside <code>.java</code> source files, KS keeps structure definitions in separate <code>.ksy</code> file</p>
</li>
<li>
<p>Preon interpetes data structure annotations in runtime, KS compiles <code>.ksy</code> into regular <code>.java</code> files first, then they&#8217;re compiled normally by Java compiler as part of the project</p>
</li>
<li>
<p>Preon supports unaligned bit streams, KS does not (yet)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>[Preon]: <a href="https://github.com/preon/preon" class="bare">https://github.com/preon/preon</a></p>
</div>
</div>
</div>
</div>
</div>

    <div id="footer">
            &copy; 2015-2017 Kaitai Project
    </div>

    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
        ga('create', 'UA-76299550-1', 'auto');
        ga('send', 'pageview');
    </script>
</body>
</html>
