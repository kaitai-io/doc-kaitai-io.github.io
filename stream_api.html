<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.0">
<title>Kaitai Stream API</title>
<link rel="stylesheet" href="styles/bootstrap.min.css">
<link rel="stylesheet" href="styles/bootstrap-theme.min.css">
<link rel="stylesheet" href="styles/main.css">
<link rel="stylesheet" href="./styles/colony.css">
</head>
<body class="article">
    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li class=""><a href="//kaitai.io/#what-is-it">What is it?</a></li>
                    <li class=""><a href="//kaitai.io/#quick-start">Quick Start</a></li>
                    <li class=""><a href="//kaitai.io/#download">Download</a></li>
                    <li class=""><a href="//formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="//kaitai.io/repl/index.html">Try it</a></li>
                    <li class="active"><a href="index.html">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<div id="header">
<h1>Kaitai Stream API</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>All source files in supported languages generated by a Kaitai Struct compiler have a goal to be human-readable, thus they utilize an extra layer of stream API. This API is followed by Kaitai Struct runtime libraries:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/kaitai-io/kaitai_struct_cpp_stl_runtime">kaitai_struct_cpp_stl_runtime</a> - for C++/STL</p>
</li>
<li>
<p><a href="https://github.com/kaitai-io/kaitai_struct_csharp_runtime">kaitai_struct_csharp_runtime</a> - for C#</p>
</li>
<li>
<p><a href="https://github.com/kaitai-io/kaitai_struct_java_runtime">kaitai_struct_java_runtime</a> - for Java</p>
</li>
<li>
<p><a href="https://github.com/kaitai-io/kaitai_struct_javascript_runtime">kaitai_struct_javascript_runtime</a> - for JavaScript</p>
</li>
<li>
<p><a href="https://github.com/kaitai-io/kaitai_struct_python_runtime">kaitai_struct_python_runtime</a> - for Python</p>
</li>
<li>
<p><a href="https://github.com/kaitai-io/kaitai_struct_ruby_runtime">kaitai_struct_ruby_runtime</a> - for Ruby</p>
</li>
<li>
<p><a href="https://github.com/kaitai-io/kaitai_struct_swift_runtime">kaitai_struct_swift_runtime</a> - for Swift</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Obviously, languages differ and thus API has slight differences, but in the nutshell, the general idea is the same. Runtime library provides a class (or collection of operations) <code>KaitaiStream</code>, which is essentially a wrapper over language&#8217;s native standard IO libraries. It features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>opening both local file input streams (if applicable) and in-memory input streams for reading in a single API</p>
</li>
<li>
<p>basic stream positioning operations (usually implemented as pass-through to stdlibs' API)</p>
</li>
<li>
<p>operations to read primitive KS types</p>
</li>
<li>
<p>processing operations to aid conversion of byte arrays into their unpacked / decrypted / deobfuscated forms</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Names of operations below are given in Kaitai Struct native standard, i.e. lower underscore case. Real-life runtime libraries adapt these names to suit target languages coding style standards, i.e. <code>read_u2be</code> becomes <code>readU2be</code> in Java, or <code>ReadU2be</code> in C#.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_stream_positioning">Stream positioning</h2>
<div class="sectionbody">
<div class="paragraph">
<p>KS works always with seekable streams using the following 3 operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>eof</code> - checks if we&#8217;ve reached end-of-stream and returns true if we did</p>
<div class="ulist">
<ul>
<li>
<p>"reaching end-of-stream" is defined being in a position where requesting of reading any single byte would result in reporting an end-of-stream error, <strong>not</strong> as in C++ <code>istream</code> semantics</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>seek(n)</code> - seeks to absolute byte position <strong>n</strong> in a stream</p>
</li>
<li>
<p><code>pos</code> - returns current position in a stream in bytes</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reading">Reading</h2>
<div class="sectionbody">
<div class="paragraph">
<p>All reading operations are supposed to "report an error" if they are unable to read requested piece of data. Means of "reporting an error" depend of target language, but generally throwing a typical stdlibs exception (<code>EOFException</code> or something like that) is preferred. The only exception for this is when a method includes <code>eos_error</code> parameter and it is set to <code>false</code> - in this case, the method is excepted to return "best effort" read result.</p>
</div>
<div class="sect2">
<h3 id="_integers">Integers</h3>
<div class="paragraph">
<p>One can read integers using one of <code>read_$S$L$E</code> operations, where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>$S</code> is either <code>u</code> if we want to read unsigned integer or <code>s</code> if we want signed one;</p>
</li>
<li>
<p><code>$L</code> is length of integer type in bytes. 1, 2, 4 and 8 bytes are supported;</p>
</li>
<li>
<p><code>$E</code> is <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a> (order of bytes): <code>l</code> for little-endian or <code>b</code> for big-endian;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A few examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>read_u8le</code> - reads 8-byte (64-bit) unsigned integer, little-endian (AKA Intel, AKA VAX, etc)</p>
</li>
<li>
<p><code>read_s2be</code> - reads 2-byte (16-bit) signed integer, big-endian (AKA "network byte order", AKA Power, AKA Motorola, etc)</p>
</li>
<li>
<p><code>read_u1</code> - reads 1-byte unsigned integer - no endianness is given as it&#8217;s pointless to do so</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Basically, it&#8217;s the same designation as used in the <code>type</code> clause in <code>.ksy</code> format.</p>
</div>
</div>
<div class="sect2">
<h3 id="_byte_arrays">Byte arrays</h3>
<div class="paragraph">
<p>There are 2 ways to read raw binary data as byte arrays:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>read_bytes(n)</code> - reads exactly <strong>n</strong> bytes from a stream; if there are less than <strong>n</strong> bytes read before hitting end-of-stream, then it reports an error</p>
</li>
<li>
<p><code>read_bytes_full</code> - reads all remaining bytes from a stream</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_strings">Strings</h3>
<div class="ulist">
<ul>
<li>
<p><code>read_str_eos(String encoding)</code></p>
</li>
<li>
<p><code>read_str_byte_limit(long len, String encoding)</code></p>
</li>
<li>
<p><code>read_strz(String encoding, int term, boolean includeTerm, boolean consumeTerm, boolean eosError)</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_processing">Processing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>These methods implement <code>process: &#8230;&#8203;</code> functionality for attributes, which basically takes a byte array and transforms it into another byte array, performing some operation usually associated with compression / encoding / encryption / obfuscation algorithms. Sometimes extra parameters are passed to these algorithms.</p>
</div>
<div class="paragraph">
<p>Note that generally these methods do not work with the stream, but get an in-memory buffer to work with, so they should be preferably implemented as <code>static</code> methods (or class methods, or the closest equivalent).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>process_xor(data, key)</code></p>
<div class="ulist">
<ul>
<li>
<p><strong>key</strong> may be a single byte or a byte array; if the language doesn&#8217;t allow 2 methods of the same name with different type signatures, it is preferred to implement 2 methods with distinct names: <code>process_xor_one</code> for single byte key and <code>process_xor_many</code> for byte array key</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>process_rotate_left(data, amount, group_size)</code></p>
</li>
<li>
<p><code>process_zlib(data)</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>

    <div id="footer">
            &copy; 2015-2018 Kaitai Project
    </div>
    <script src="js/jquery-1.12.3.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
        ga('create', 'UA-76299550-1', 'auto');
        ga('send', 'pageview');
    </script>
</body>
</html>
