<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.18">
<meta name="author" content="Kaitai Project">
<title>Kaitai Struct User Guide</title>
<link rel="stylesheet" href="styles/pygments-default.css">
<link rel="stylesheet" href="styles/bootstrap.min.css">
<link rel="stylesheet" href="styles/bootstrap-theme.min.css">
<link rel="stylesheet" href="styles/main.css">
<link rel="stylesheet" href="styles/pygments-default.css">
<link rel="stylesheet" href="./styles/colony.css">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MFSBBRGREL"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MFSBBRGREL');
</script>
<link rel="stylesheet" href="styles/asciidoctor-tabs.css">
</head>
<body class="article toc2 toc-left">
    <nav class="navbar navbar-inverse navbar-fixed-top" id="main-navbar">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <span class="navbar-brand">Kaitai Struct</span>
            </div>
            <div class="collapse navbar-collapse" id="main-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li class=""><a href="//kaitai.io/#what-is-it">What is it?</a></li>
                    <li class=""><a href="//kaitai.io/#quick-start">Quick Start</a></li>
                    <li class=""><a href="//kaitai.io/#download">Download</a></li>
                    <li class=""><a href="//formats.kaitai.io/">Format Gallery</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="https://ide.kaitai.io/">Try it &mdash; Web IDE</a></li>
                    <li class="active"><a href="index.html">Documentation</a></li>
                </ul>
            </div>
        </div>
    </nav>
<div id="header">
<h1>Kaitai Struct User Guide</h1>
<div class="details">
<span id="author" class="author">Kaitai Project</span><br>
<span id="revnumber">version 0.10</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#install-invoke">2. Installation and invocation</a>
<ul class="sectlevel2">
<li><a href="#web-ide">2.1. Web IDE</a></li>
<li><a href="#ksc">2.2. Desktop / console version</a></li>
</ul>
</li>
<li><a href="#_workflow_overview">3. Workflow overview</a></li>
<li><a href="#_kaitai_struct_language">4. Kaitai Struct language</a>
<ul class="sectlevel2">
<li><a href="#fixed-size-struct">4.1. Fixed-size structures</a></li>
<li><a href="#docstrings">4.2. Docstrings</a></li>
<li><a href="#magic">4.3. Checking for "magic" signatures</a></li>
<li><a href="#var-length-struct">4.4. Variable-length structures</a></li>
<li><a href="#delimited-struct">4.5. Delimited structures</a></li>
<li><a href="#enums">4.6. Enums (named integer constants)</a></li>
<li><a href="#types">4.7. Substructures (subtypes)</a></li>
<li><a href="#_accessing_attributes_in_other_types">4.8. Accessing attributes in other types</a></li>
<li><a href="#_conditionals">4.9. Conditionals</a></li>
<li><a href="#_repetitions">4.10. Repetitions</a></li>
<li><a href="#tlv">4.11. Typical TLV implementation (switching types on an expression)</a></li>
<li><a href="#_instances_data_beyond_the_sequence">4.12. Instances: data beyond the sequence</a></li>
<li><a href="#_value_instances">4.13. Value instances</a></li>
<li><a href="#_bit_sized_integers">4.14. Bit-sized integers</a></li>
<li><a href="#ksy-documentation">4.15. Documenting your spec</a></li>
<li><a href="#meta">4.16. Meta section</a></li>
</ul>
</li>
<li><a href="#stream">5. Streams and substreams</a>
<ul class="sectlevel2">
<li><a href="#_limiting_total_size_of_structure">5.1. Limiting total size of structure</a></li>
<li><a href="#repeat-until-size-limit">5.2. Repeating until total size reaches limit</a></li>
<li><a href="#_relative_positioning">5.3. Relative positioning</a></li>
<li><a href="#_absolute_positioning">5.4. Absolute positioning</a></li>
<li><a href="#_choosing_a_substream">5.5. Choosing a substream</a></li>
<li><a href="#process">5.6. Processing: dealing with compressed, obfuscated and encrypted data</a></li>
</ul>
</li>
<li><a href="#_expression_language">6. Expression language</a>
<ul class="sectlevel2">
<li><a href="#_basic_data_types">6.1. Basic data types</a></li>
<li><a href="#_composite_data_types">6.2. Composite data types</a></li>
<li><a href="#_operators">6.3. Operators</a></li>
<li><a href="#methods">6.4. Methods</a></li>
</ul>
</li>
<li><a href="#_advanced_techniques">7. Advanced techniques</a>
<ul class="sectlevel2">
<li><a href="#switch-advanced">7.1. Advanced switching</a></li>
<li><a href="#do-nothing">7.2. Do nothing</a></li>
<li><a href="#delimited-struct-advanced">7.3. Advanced delimited structures</a></li>
<li><a href="#meta-imports">7.4. Importing types from other files</a></li>
<li><a href="#opaque-types">7.5. Opaque types: plugging in external code</a></li>
<li><a href="#custom-process">7.6. Custom processing routines</a></li>
<li><a href="#_enforcing_parent_type">7.7. Enforcing parent type</a></li>
<li><a href="#typecast">7.8. Typecasting</a></li>
<li><a href="#calc-endian">7.9. Calculated default endianness</a></li>
<li><a href="#param-types">7.10. Parametric types</a></li>
<li><a href="#repeat-index">7.11. Repetition index</a></li>
</ul>
</li>
<li><a href="#_common_pitfalls">8. Common pitfalls</a>
<ul class="sectlevel2">
<li><a href="#_specifying_size_creates_a_substream">8.1. Specifying size creates a substream</a></li>
<li><a href="#_not_specifying_size_does_not_create_a_substream">8.2. Not specifying size does not create a substream</a></li>
<li><a href="#_applying_process_without_a_size">8.3. Applying <code>process</code> without a size</a></li>
<li><a href="#keys-repeated">8.4. Keys relating to the whole array and to each element in repeated attributes</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kaitai Struct is a domain-specific language (DSL) that is designed
with one particular task in mind: dealing with arbitrary binary
formats.</p>
</div>
<div class="paragraph">
<p>Parsing binary formats is hard, and there&#8217;s a reason for that: such
formats were designed to be machine-readable, not human-readable. Even
when one&#8217;s working with a clean, well-documented format, there are
multiple pitfalls that await the developer: endianness issues,
in-memory structure alignment, variable size structures, conditional
fields, repetitions, fields that depend on other fields previously
read, etc, etc, to name a few.</p>
</div>
<div class="paragraph">
<p>Kaitai Struct tries to isolate the developer from all these details
and allow them to focus on the things that matter: the data structure
itself, not particular ways to read or write it.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="install-invoke">2. Installation and invocation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kaitai Struct has a somewhat diverse infrastructure around it. This
chapter will give an overview of the options available.</p>
</div>
<div class="sect2">
<h3 id="web-ide">2.1. Web IDE</h3>
<div class="paragraph">
<p>If you&#8217;re going to try Kaitai Struct for the first time,
the Web IDE is probably the easiest way to get started. Just open
<a href="https://ide.kaitai.io/">Kaitai Struct Web IDE</a> and you&#8217;re
ready to go:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/webide_png_example.png" alt="Kaitai Struct Web IDE (sample PNG file + png.ksy loaded)" width="1335" height="811">
</div>
<div class="title">Figure 1: Kaitai Struct Web IDE (sample PNG file + png.ksy loaded)</div>
</div>
<div class="paragraph">
<p>A list of Web IDE features is available on the <a href="https://github.com/kaitai-io/kaitai_struct_webide/wiki/Features"><em>kaitai_struct_webide</em> GitHub wiki</a>.</p>
</div>
<div class="paragraph">
<p>Note that there are two different versions of the Web IDE:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://ide.kaitai.io/" class="bare">https://ide.kaitai.io/</a> — <strong>stable</strong> version, has the stable of the Kaitai Struct compiler (currently 0.10, released 2022-07-08)</p>
</li>
<li>
<p><a href="https://ide.kaitai.io/devel/" class="bare">https://ide.kaitai.io/devel/</a> — unstable development version, always has the <strong>latest</strong> compiler (the most recent 0.11-SNAPSHOT)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you want to use the latest features, use the <a href="https://ide.kaitai.io/devel/"><strong>devel</strong> Web IDE</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="ksc">2.2. Desktop / console version</h3>
<div class="paragraph">
<p>If you don&#8217;t fancy using a hex dump in a browser, or want to integrate Kaitai Struct into your project build
process automation, you&#8217;d want a desktop / console solution. Of
course, Kaitai Struct offers that as well.</p>
</div>
<div class="sect3">
<h4 id="ksc-install">2.2.1. Installation</h4>
<div class="paragraph">
<p>Please refer to the <a href="//kaitai.io/#download">official website</a> for
installation instructions. After installation, you will have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ksc</code> (or <code>kaitai-struct-compiler</code>) — command-line Kaitai Struct
compiler, a program that translates <code>.ksy</code> into parsing libraries in
a chosen target language.</p>
</li>
<li>
<p><code>ksv</code> (or <code>kaitai-struct-visualizer</code>, optional) — console visualizer</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>ksc</code> or <code>ksv</code> shorthand might be not available if your system doesn&#8217;t
support symbolic links — just use the full name in that case.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you&#8217;re going to invoke <code>ksc</code> frequently, you&#8217;d probably want to add
it to your executable searching <code>PATH</code>, so you don&#8217;t have to type the full
path to it every time. You&#8217;d get that automatically on .deb package
and Windows .msi install (provided you don&#8217;t disable that option) -
but it might take some extra manual setup if you use a generic .zip
package.</p>
</div>
</div>
<div class="sect3">
<h4 id="invocation">2.2.2. Invocation</h4>
<div class="paragraph">
<p>Invoking <code>ksc</code> is easy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>ksc <span class="tok-o">[</span>options<span class="tok-o">]</span> &lt;file&gt;...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Common options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;file&gt;&#8230;&#8203;</code> — source files (.ksy)</p>
</li>
<li>
<p><code>-t &lt;language&gt; | --target &lt;language&gt;</code> — target languages (<code>cpp_stl</code>,
<code>csharp</code>, <code>java</code>, <code>javascript</code>, <code>perl</code>, <code>php</code>, <code>python</code>, <code>ruby</code>, <code>all</code>)</p>
<div class="ulist">
<ul>
<li>
<p><code>all</code> is a special case: it compiles all possible target
languages, creating language-specific directories (as per language
identifiers) inside output directory, and then creating output
module(s) for each language starting from there</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>-d &lt;directory&gt; | --outdir &lt;directory&gt;</code> — output directory
(filenames will be auto-generated)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Language-specific options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>--dotnet-namespace &lt;namespace&gt;</code> — .NET namespace (C# only, default: Kaitai)</p>
</li>
<li>
<p><code>--java-package &lt;package&gt;</code> — Java package (Java only, default: root package)</p>
</li>
<li>
<p><code>--php-namespace &lt;namespace&gt;</code> — PHP namespace (PHP only, default: root package)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Misc options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>--verbose</code> — verbose output</p>
</li>
<li>
<p><code>--help</code> — display usage information and exit</p>
</li>
<li>
<p><code>--version</code> — display version information and exit</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_workflow_overview">3. Workflow overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main idea of Kaitai Struct is that you create a description of a binary data
structure format using a formal language, save it as a <code>.ksy</code> file, and
then compile it with the Kaitai Struct compiler into a target programming language.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_kaitai_struct_language">4. Kaitai Struct language</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With the workflow issues out of the way, let&#8217;s concentrate on the Kaitai
Struct language itself.</p>
</div>
<div class="sect2">
<h3 id="fixed-size-struct">4.1. Fixed-size structures</h3>
<div class="paragraph">
<p>Probably the simplest thing Kaitai Struct can do is reading fixed-size structures.
You might know them as C struct definitions — consider something like
this fictional database entry that keeps track of dog show
participants:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-k">struct</span> <span class="tok-p">{</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-kt">char</span><span class="tok-w"> </span><span class="tok-n">uuid</span><span class="tok-p">[</span><span class="tok-mi">16</span><span class="tok-p">];</span><span class="tok-w">       </span><span class="tok-cm">/* 128-bit UUID */</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-kt">char</span><span class="tok-w"> </span><span class="tok-n">name</span><span class="tok-p">[</span><span class="tok-mi">24</span><span class="tok-p">];</span><span class="tok-w">       </span><span class="tok-cm">/* Name of the animal */</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-kt">uint16_t</span><span class="tok-w"> </span><span class="tok-n">birth_year</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-cm">/* Year of birth, used to calculate the age */</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-kt">double</span><span class="tok-w"> </span><span class="tok-n">weight</span><span class="tok-p">;</span><span class="tok-w">       </span><span class="tok-cm">/* Current weight in kg */</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-kt">int32_t</span><span class="tok-w"> </span><span class="tok-n">rating</span><span class="tok-p">;</span><span class="tok-w">      </span><span class="tok-cm">/* Rating, can be negative */</span><span class="tok-w"></span>
<span class="tok-p">}</span><span class="tok-w"> </span><span class="tok-n">animal_record</span><span class="tok-p">;</span><span class="tok-w"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And here is how it would look in .ksy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">animal_record</span>
  <span class="tok-nt">endian</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">be</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">uuid</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">16</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">name</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">24</span>
    <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">UTF-8</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">birth_year</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u2</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">weight</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">f8</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rating</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">s4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s a <a href="https://learnxinyminutes.com/docs/yaml/">YAML</a>-based format,
plain and simple. Every .ksy file is a type description. Everything
starts with a <code>meta</code> section: this is where we specify top-level info on
the whole structure we describe. There are two important things here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> specifies the name of the structure</p>
</li>
<li>
<p><code>endian</code> specifies default
<a href="https://en.wikipedia.org/wiki/Endianness">endianness</a>:</p>
<div class="ulist">
<ul>
<li>
<p><code>be</code> for big-endian (AKA "network byte order", AKA Motorola, etc)</p>
</li>
<li>
<p><code>le</code> for little-endian (AKA Intel, AKA VAX, etc)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>With that out of the way, we use a <code>seq</code> element with an array (ordered
sequence of elements) in it to describe which attributes this structure
consists of. Every attribute includes several keys, namely:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> is used to give the attribute a name</p>
</li>
<li>
<p><code>type</code> designates the attribute type:</p>
<div class="ulist">
<ul>
<li>
<p>no type means that we&#8217;re dealing with just a raw byte array; <code>size</code>
is to be used to designate number of bytes in this array</p>
</li>
<li>
<p><code>s1</code>, <code>s2</code>, <code>s4</code>, <code>u1</code>, <code>u2</code>, <code>u4</code>, etc for integers</p>
<div class="ulist">
<ul>
<li>
<p>"s" means signed, "u" means unsigned</p>
</li>
<li>
<p>number is the number of bytes</p>
</li>
<li>
<p>if you need to specify non-default endianness, you can force it by
appending <code>be</code> or <code>le</code> — i.e. <code>s4be</code>, <code>u8le</code>, etc</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>f4</code> and <code>f8</code> for IEEE 754 floating point numbers; <code>4</code> and <code>8</code>,
again, designate the number of bytes (single or double precision)</p>
<div class="ulist">
<ul>
<li>
<p>if you need to specify non-default endianness, you can force it by
appending <code>be</code> or <code>le</code> — i.e. <code>f4be</code>, <code>f8le</code>, etc</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>str</code> is used for strings; that is almost the same as "no type", but a
string has a concept of encoding, which must be specified using
<code>encoding</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The YAML-based syntax might look a little more verbose than C-like structs,
but there are a few good reasons to use it. It is consistent, it is
easily extendable, and it&#8217;s easy to parse, so it&#8217;s easy to make your own
programs/scripts that work with .ksy specs.</p>
</div>
</div>
<div class="sect2">
<h3 id="docstrings">4.2. Docstrings</h3>
<div class="paragraph">
<p>A very simple example is that we can add docstrings to every attribute,
using syntax like that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span>  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rating</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">s4</span>
    <span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">Rating, can be negative</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These docstrings are not just the comments in the .ksy file, they&#8217;ll actually get
exported into the target language as well (for example, in Java they&#8217;ll
become JavaDoc, in Ruby they&#8217;ll become RDoc/YARD, etc). This, in turn,
is super helpful when editing the code in various IDEs that will
generate reminder popups for intelligent completion, when you browse
through class attributes:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="img/completion_javadoc.png" alt="JavaDoc is generated automatically from `doc`" width="1188" height="366">
</div>
<div class="title">Figure 2: JavaDoc is generated automatically from <code>doc</code></div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>You can use YAML
folded style strings for longer documentation that spans multiple lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span>  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">opcode</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
    <span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-p tok-p-Indicator">|</span>
      <span class="tok-no">Operation code that defines which operation should be performed</span>
      <span class="tok-no">by a virtual machine. Subsequent parameters for operation depend</span>
      <span class="tok-no">on the value of opcode.</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="magic">4.3. Checking for "magic" signatures</h3>
<div class="paragraph">
<p>Many file formats use some sort of safeguard measure against using a
completely different file type in place of the required file type. The
simple way to do so is to include some "magic" bytes (AKA "file
signature"): for example, checking that the first bytes of the file are equal to
their intended values provides at least some degree of protection
against such blunders.</p>
</div>
<div class="paragraph">
<p>To specify "magic" bytes (i.e. fixed content) in structures, Kaitai Struct includes
a special <code>contents</code> key. For example, this is the beginning of a <code>seq</code>
for Java .class files:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">magic</span>
    <span class="tok-nt">contents</span><span class="tok-p">:</span> <span class="tok-p tok-p-Indicator">[</span><span class="tok-nv">0xca</span><span class="tok-p tok-p-Indicator">,</span> <span class="tok-nv">0xfe</span><span class="tok-p tok-p-Indicator">,</span> <span class="tok-nv">0xba</span><span class="tok-p tok-p-Indicator">,</span> <span class="tok-nv">0xbe</span><span class="tok-p tok-p-Indicator">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This reads the first 4 bytes and compares them to the 4 bytes <code>CA FE BA BE</code>. If
there is any mismatch (or less than 4 bytes are read),
it throws an exception and stops parsing at an early stage, before any
damage (pointless allocation of huge structures, waste of CPU cycles)
is done.</p>
</div>
<div class="paragraph">
<p>Note that <code>contents</code> is very flexible and you can specify:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A UTF-8 string — bytes from such a string would be checked against</p>
</li>
<li>
<p>An array with:</p>
<div class="ulist">
<ul>
<li>
<p>bytes in decimal representation</p>
</li>
<li>
<p>bytes in hexadecimal representation, starting with 0x</p>
</li>
<li>
<p>UTF-8 strings</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the case of using an array, all elements' byte representations would be
concatenated and expected in sequence. Some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span>  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">magic1</span>
    <span class="tok-nt">contents</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">JFIF</span>
    <span class="tok-c1"># expects bytes: 4A 46 49 46</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">magic2</span>
    <span class="tok-c1"># we can use YAML block-style arrays as well</span>
    <span class="tok-nt">contents</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0xca</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0xfe</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0xba</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0xbe</span>
    <span class="tok-c1"># expects bytes: CA FE BA BE</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">magic3</span>
    <span class="tok-nt">contents</span><span class="tok-p">:</span> <span class="tok-p tok-p-Indicator">[</span><span class="tok-nv">CAFE</span><span class="tok-p tok-p-Indicator">,</span> <span class="tok-nv">0</span><span class="tok-p tok-p-Indicator">,</span> <span class="tok-nv">BABE</span><span class="tok-p tok-p-Indicator">]</span>
    <span class="tok-c1"># expects bytes: 43 41 46 45 00 42 41 42 45</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>More extreme examples to illustrate the idea (i.e. possible, but
definitely not recommended in real-life specs):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span>  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">magic4</span>
    <span class="tok-nt">contents</span><span class="tok-p">:</span> <span class="tok-p tok-p-Indicator">[</span><span class="tok-nv">foo</span><span class="tok-p tok-p-Indicator">,</span> <span class="tok-nv">0</span><span class="tok-p tok-p-Indicator">,</span> <span class="tok-nv">A</span><span class="tok-p tok-p-Indicator">,</span> <span class="tok-nv">0xa</span><span class="tok-p tok-p-Indicator">,</span> <span class="tok-nv">42</span><span class="tok-p tok-p-Indicator">]</span>
    <span class="tok-c1"># expects bytes: 66 6F 6F 00 41 0A 2A</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">magic5</span>
    <span class="tok-nt">contents</span><span class="tok-p">:</span> <span class="tok-p tok-p-Indicator">[</span><span class="tok-nv">1</span><span class="tok-p tok-p-Indicator">,</span> <span class="tok-nv">0x55</span><span class="tok-p tok-p-Indicator">,</span> <span class="tok-s">&#39;▒,3&#39;</span><span class="tok-p tok-p-Indicator">,</span> <span class="tok-nv">3</span><span class="tok-p tok-p-Indicator">]</span>
    <span class="tok-c1"># expects bytes: 01 55 E2 96 92 2C 33 03</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
There&#8217;s no need to specify <code>type</code> or <code>size</code> for fixed contents
data — it all comes naturally from the <code>contents</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="var-length-struct">4.4. Variable-length structures</h3>
<div class="paragraph">
<p>Many protocols and file formats tend to conserve bytes, especially for
strings. Sure, it&#8217;s stupid to have a fixed 512-byte buffer for a string
that typically is 3-5 bytes long and only rarely can be up to 512 bytes.</p>
</div>
<div class="paragraph">
<p>One of the most common methods used to mitigate this problem is to use
some integer to designate length of the string, and store only
designated number of bytes in the stream. Unfortunately, this yields
a variable-length structure, and it&#8217;s impossible to describe such a thing
using C-style structs. However, it&#8217;s not a problem for Kaitai Struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_str</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_len</span>
    <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">UTF-8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the <code>size</code> field: we use not a constant, but a reference to a field
that we&#8217;ve just parsed from a stream. Actually, you can do much more
than that — you can use a full-blown expression language in <code>size</code>
field. For example, what if we&#8217;re dealing with UTF-16 strings and
<code>my_len</code> value designates not a number of bytes, but number of byte
pairs?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_str</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_len * 2</span>
    <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">UTF-16LE</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One can just multiply <code>my_len</code> by 2 — and voila — here&#8217;s our UTF-16
string. Expression language is very powerful, we&#8217;ll be talking more
about it later.</p>
</div>
<div class="paragraph">
<p>Last, but not least, we can specify a <code>size</code> that spans automatically to
the end of the stream. For that one, we&#8217;ll use a slightly different
syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">some_int</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">string_spanning_to_the_end_of_file</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">UTF-8</span>
    <span class="tok-nt">size-eos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">true</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="delimited-struct">4.5. Delimited structures</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
All features specified in this section are demonstrated on
strings, but the same features should work on any user types as well.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Another popular way to avoid allocating huge fixed-size buffers is to
use some sort of trailing delimiter. The most well-known example of
this is probably the null-terminated string which became a standard
string representation in C:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>61 62 63 00</pre>
</div>
</div>
<div class="paragraph">
<p>These 4 bytes actually represent the 3-character string "abc", plus one extra
trailing byte "0" (AKA null) which serves as a delimiter or
terminator. By agreement, C strings cannot include a zero byte: every time
a function in C sees that either in stream or in memory, it considers
that as a special mark to stop processing.</p>
</div>
<div class="paragraph">
<p>In Kaitai Struct, you can define all sorts of delimited
structures. For example, this is how you define a null-terminated
string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_string</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">terminator</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0</span>
    <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">UTF-8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As this is a very common thing, there&#8217;s a shortcut for <code>type: str</code> and
<code>terminator: 0</code>. One can write this as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_string</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">strz</span>
    <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">UTF-8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, you can use any other byte (for example, <code>0xa</code>, AKA
newline) as a terminator. This gives Kaitai Struct some limited
capabilities to parse certain text formats as well.</p>
</div>
<div class="paragraph">
<p>Reading "until the terminator byte is encountered" could be
dangerous. What if we never encounter that byte?</p>
</div>
<div class="paragraph">
<p>Another very widespread model is actually having <strong>both</strong> a fixed-sized
buffer for a string <strong>and</strong> a terminator. This is typically an artifact
of serializing structures like this from C. For example, take this
structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-k">struct</span> <span class="tok-p">{</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-kt">char</span><span class="tok-w"> </span><span class="tok-n">name</span><span class="tok-p">[</span><span class="tok-mi">16</span><span class="tok-p">];</span><span class="tok-w">       </span><span class="tok-cm">/* Name of the animal */</span><span class="tok-w"></span>
<span class="tok-w">    </span><span class="tok-kt">uint16_t</span><span class="tok-w"> </span><span class="tok-n">birth_year</span><span class="tok-p">;</span><span class="tok-w"> </span><span class="tok-cm">/* Year of birth, used to calculate the age */</span><span class="tok-w"></span>
<span class="tok-p">}</span><span class="tok-w"> </span><span class="tok-n">animal_record</span><span class="tok-p">;</span><span class="tok-w"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>and do the following in C:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-k">struct</span> <span class="tok-nc">animal_record</span><span class="tok-w"> </span><span class="tok-n">rec</span><span class="tok-p">;</span><span class="tok-w"></span>
<span class="tok-n">strcpy</span><span class="tok-p">(</span><span class="tok-n">rec</span><span class="tok-p">.</span><span class="tok-n">name</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-s">&quot;Princess&quot;</span><span class="tok-p">);</span><span class="tok-w"></span>
<span class="tok-c1">// then, after some time, the same record is reused</span>
<span class="tok-n">strcpy</span><span class="tok-p">(</span><span class="tok-n">rec</span><span class="tok-p">.</span><span class="tok-n">name</span><span class="tok-p">,</span><span class="tok-w"> </span><span class="tok-s">&quot;Sam&quot;</span><span class="tok-p">);</span><span class="tok-w"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>After the first <code>strcpy</code> operation, the buffer will look like:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>50 72 69 6e|63 65 73 73|00 ?? ?? ??|?? ?? ?? ??| |Princess.???????|</pre>
</div>
</div>
<div class="paragraph">
<p>And after the second <code>strcpy</code>, the following will remain in the
memory:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>53 61 6d 00|63 65 73 73|00 ?? ?? ??|?? ?? ?? ??| |Sam.cess.???????|</pre>
</div>
</div>
<div class="paragraph">
<p>Effectively, the buffer is still 16 bytes, but the only meaningful
contents it has is up to first null terminator. Everything beyond that
is garbage left over from either the buffer not being initialized at all
(these <code>??</code> bytes could contain anything), or it will contain parts of
strings previously occupying this buffer.</p>
</div>
<div class="paragraph">
<p>It&#8217;s easy to model that kind of behavior in Kaitai Struct as well,
just by combining <code>size</code> and <code>terminator</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">name</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">16</span>
    <span class="tok-nt">terminator</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0</span>
    <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">UTF-8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This works in 2 steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>size</code> always that exactly 16 bytes would be read from the stream.</p>
</li>
<li>
<p><code>terminator</code>, given that <code>size</code> is present, only works inside these
16 bytes, cutting string short early with the first terminator byte
encountered, saving application from getting all that trailing
garbage.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="enums">4.6. Enums (named integer constants)</h3>
<div class="paragraph">
<p>The nature of binary format encoding dictates that in many cases
we&#8217;ll be using some kind of integer constants to encode certain
entities. For example, an IP packet uses a 1-byte integer to
encode the protocol type for the payload: 6 would mean "TCP" (which gives us TCP/IP), 17 would mean "UDP" (which yields UDP/IP), and 1 means
"ICMP".</p>
</div>
<div class="paragraph">
<p>It is possible to live with just raw integers, but most programming
languages actually provide a way to program using meaningful string names
instead. This approach is usually dubbed "enums" and it&#8217;s totally
possible to generate an enum in Kaitai Struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">protocol</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
    <span class="tok-nt">enum</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ip_protocol</span>
<span class="tok-nt">enums</span><span class="tok-p">:</span>
  <span class="tok-nt">ip_protocol</span><span class="tok-p">:</span>
    <span class="tok-nt">1</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">icmp</span>
    <span class="tok-nt">6</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">tcp</span>
    <span class="tok-nt">17</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">udp</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two things that should be done to declare a enum:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We add an <code>enums</code> key on the type level (i.e. on the same level as
<code>seq</code> and <code>meta</code>). Inside that key, we add a map, keys of it being enum names (in this example, there&#8217;s only one enum declared, <code>ip_protocol</code>)
and values being yet another map, which maps integer values into
identifiers.</p>
</li>
<li>
<p>We add an <code>enum: &#8230;&#8203;</code> parameter to every attribute that&#8217;s going to be
represented by that enum, instead of just being a raw integer. Note that
such attributes must have some sort of integer type in the first place
(i.e. <code>type: u*</code> or <code>type: s*</code>).</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="types">4.7. Substructures (subtypes)</h3>
<div class="paragraph">
<p>What do we do if we need to use many of the strings in such a format?
Writing so many repetitive <code>my_len</code>- / <code>my_str</code>-style pairs would be so
bothersome and error-prone. Fear not, we can define another type,
defining it in the same file, and use it as a custom type in a stream:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">track_title</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str_with_len</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">album_title</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str_with_len</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">artist_name</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str_with_len</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">str_with_len</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">value</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
        <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">UTF-8</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we define another type named <code>str_with_len</code>, which we reference
just by doing <code>type: str_with_len</code>. The type itself is defined using the
<code>types:</code> key at the top level. That&#8217;s a map, and inside it we can define as
many subtypes as we want. We define just one, and inside it we nest
the exact same syntax as we use for the type description on the top
level — i.e. the same <code>seq</code> designation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
There&#8217;s no need for <code>meta/id</code> here, as the type name is derived from the
<code>types</code> key name here.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course, one can actually have more levels of subtypes:</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_accessing_attributes_in_other_types">4.8. Accessing attributes in other types</h3>
<div class="paragraph">
<p>Expression language (used, for example, in a <code>size</code> key) allows you to
refer not only to attributes in the current type, but also in other types.
Consider this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">header</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">main_header</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">header.body_len</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">main_header</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">magic</span>
        <span class="tok-nt">contents</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">MY-SUPER-FORMAT</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body_len</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>body_len</code> attribute was in the same type as <code>body</code>, we could just
use <code>size: body_len</code>. However, in this case we&#8217;ve decided to split the
main header into a separate subtype, so we&#8217;ll have to access it using the <code>.</code>
operator — i.e. <code>size: header.body_len</code>.</p>
</div>
<div class="paragraph">
<p>One can chain attributes with <code>.</code> to dig deeper into type
hierarchy — e.g. <code>size: header.subheader_1.subsubheader_1_2.field_4</code>.
But sometimes we need just the opposite: how do we access upper-level
elements from lower-level types? Kaitai Struct provides two options here:</p>
</div>
<div class="sect3">
<h4 id="_parent">4.8.1. <code>_parent</code></h4>
<div class="paragraph">
<p>One can use the special pseudo-attribute <code>_parent</code> to access the parent
structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">TODO</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_root">4.8.2. <code>_root</code></h4>
<div class="paragraph">
<p>In some cases, it would be way too impractical to write tons of
<code>_parent._parent._parent._parent...</code> or just plain impossible (if you&#8217;re
describing a type which might be used on several different levels, thus
different number of <code>_parent</code> would be needed). In this case, we can use a
special pseudo-attribute <code>_root</code> to just start navigating from the very
top-level type:</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">header</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">main_header</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">main_header</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">magic</span>
        <span class="tok-nt">contents</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">MY-SUPER-FORMAT</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body_len</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">subbody_len</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conditionals">4.9. Conditionals</h3>
<div class="paragraph">
<p>Some protocols and file formats have optional fields, which only exist
in some conditions. For example, one can have some byte first that
designates if some other field exists (1) or not (0). In Kaitai Struct, you can do that
using the <code>if</code> key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">has_crc32</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">crc32</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-nt">if</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">has_crc32 != 0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we again use expression language to specify a boolean
expression in the <code>if</code> key. If that expression is true, the field is parsed and
we&#8217;ll get a result. If that expression is false, the field will be skipped
and we&#8217;ll get a <code>null</code> (or its closest equivalent in our target
programming language) if we try to get it.</p>
</div>
<div class="paragraph">
<p>At this point, you might wonder how that plays together with enums.
After you mark some integer as "enum", it&#8217;s no longer just an integer,
so you can&#8217;t compare it directly with the number. Instead you&#8217;re
expected to compare it to other enum values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_animal</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
    <span class="tok-nt">enum</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">animal</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">dog_tag</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-c1"># Comparing to enum literal</span>
    <span class="tok-nt">if</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_animal == animal::dog</span>
<span class="tok-nt">enums</span><span class="tok-p">:</span>
  <span class="tok-nt">animal</span><span class="tok-p">:</span>
    <span class="tok-nt">1</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">cat</span>
    <span class="tok-nt">2</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">dog</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are other enum operations available, which we&#8217;ll cover in the
expression language guide later.</p>
</div>
</div>
<div class="sect2">
<h3 id="_repetitions">4.10. Repetitions</h3>
<div class="paragraph">
<p>Most real-life file formats do not contain only one copy of some
element, but might contain several copies, i.e. they repeat the same
pattern over and over. Repetition might be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>element repeated up to the very end of the stream</p>
</li>
<li>
<p>element repeated a pre-defined number of times</p>
</li>
<li>
<p>element repeated while some condition is not satisfied (or until some
condition becomes true)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Kaitai Struct supports all these types of repetitions. In all cases, it will create
a resizable array (or nearest equivalent available in the target language)
and populate it with elements.</p>
</div>
<div class="sect3">
<h4 id="repeat-eos">4.10.1. Repeat until end of stream</h4>
<div class="paragraph">
<p>This is the simplest kind of repetition, done by specifying
<code>repeat: eos</code>. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">numbers</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">eos</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This yields an array of unsigned integers, each 4 bytes long, which
spans till the end of the stream. Note that if we&#8217;ve got a number of bytes left in the
stream that&#8217;s not divisible by 4 (for example, 7), we&#8217;ll end up reading
as much as possible, and then the parsing procedure will throw an
end-of-stream exception.</p>
</div>
<div class="paragraph">
<p>Of course, you can do this with any type,
including user-defined types (subtypes):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">filenames</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">filename</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">eos</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">filename</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">name</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">8</span>
        <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ASCII</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ext</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">3</span>
        <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ASCII</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This one defines an array of records of type <code>filename</code>. Each individual
<code>filename</code> consists of 8-byte <code>name</code> and 3-byte <code>ext</code> strings in ASCII
encoding.</p>
</div>
</div>
<div class="sect3">
<h4 id="_repeat_for_a_number_of_times">4.10.2. Repeat for a number of times</h4>
<div class="paragraph">
<p>One can repeat an element a certain number of times. For that, we&#8217;ll
need an expression that will give us the number of iterations (which would
be exactly the number of items in resulting array). It could be a simple
constant to read exactly 12 numbers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">numbers</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">12</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or we might reference some attribute here to have an array with the length
specified inside the format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_floats</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">floats</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">f8</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_floats</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, using expression language, we can even do some more complex math on
it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">width</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">height</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">matrix</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">f8</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">width * height</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This one specifies the <code>width</code> and <code>height</code> of the matrix first, then parses
as many <code>matrix</code> elements as needed to fill a <code>width</code> × <code>height</code> matrix
(although note that it won&#8217;t be a true 2D matrix: it would still be just
a regular 1D array, and you&#8217;ll need to convert (x, y) coordinates to
indices in that 1D array manually).</p>
</div>
</div>
<div class="sect3">
<h4 id="_repeat_until_condition_is_met">4.10.3. Repeat until condition is met</h4>
<div class="paragraph">
<p>Some formats don&#8217;t specify the number of elements in array, but instead
just use some sort of special element as a terminator that signifies end
of data. Kaitai Struct can do that as well using <code>repeat-until</code> syntax, for
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">numbers</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">s4</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">until</span>
    <span class="tok-nt">repeat-until</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_ == -1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This one reads 4-byte signed integer numbers until encountering <code>-1</code>. On
encountering <code>-1</code>, the loop will stop and further sequence elements (if
any) will be processed. Note that <code>-1</code> would still be added to array.</p>
</div>
<div class="paragraph">
<p>Underscore (<code>_</code>) is used as a special variable name that refers to the
element that we&#8217;ve just parsed. When parsing an array of user types, it
is possible to write a <code>repeat-until</code> expression that would reference some
attribute inside that user type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">records</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">buffer_with_len</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">until</span>
    <span class="tok-nt">repeat-until</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_.len == 0</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">buffer_with_len</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">value</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tlv">4.11. Typical TLV implementation (switching types on an expression)</h3>
<div class="paragraph">
<p>"TLV" stands for "type-length-value", and it&#8217;s a very common staple in
many formats. The basic idea is that we use a modular and
reverse-compatible format. On the top level, it&#8217;s very simple: we know
that the whole format is just an array of records (<code>repeat: eos</code> or
<code>repeat: expr</code>). Each record starts the same: there is some marker that
specifies the <em>type</em> of the record and an integer that specifies the record&#8217;s
<em>length</em>. After that, the record&#8217;s body follows, and the body format
depends on the <em>type</em> marker. One can easily specify that basic record
outline in Kaitai Struct like that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, how do we specify the format for <code>body</code> that depends on
<code>rec_type</code>? One of the approaches is using conditionals, as we&#8217;ve seen
before:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body_1</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_1</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
    <span class="tok-nt">if</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type == 1</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body_2</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_2</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
    <span class="tok-nt">if</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type == 2</span>
  <span class="tok-c1"># ...</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body_unidentified</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
    <span class="tok-nt">if</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type != 1 and rec_type != 2</span> <span class="tok-c1"># and ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, it&#8217;s easy to see why it&#8217;s not a very good solution:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We end up writing lots of repetitive lines</p>
</li>
<li>
<p>We create lots of <code>body_*</code> attributes in a type, while in reality only
one <code>body</code> would exist — everything else would fail the <code>if</code> comparison
and thus would be null</p>
</li>
<li>
<p>If we want to catch up the "else" branch, i.e. match everything not
matched with our <code>if</code>s, we have to write an inverse of sum of <code>if</code>s
manually. For anything more than 1 or 2 types it quickly becomes a mess.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>That is why Kaitai Struct offers an alternative solution. We can use a switch type
operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span>
      <span class="tok-nt">switch-on</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
      <span class="tok-nt">cases</span><span class="tok-p">:</span>
        <span class="tok-nt">1</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_1</span>
        <span class="tok-nt">2</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is much more concise and easier to maintain, isn&#8217;t it? And note
that <code>size</code> is specified on the attribute level, thus it applies to all
possible type values, setting us a good hard limit. What&#8217;s even better —
even if you&#8217;re missing the match, as long as you have <code>size</code> specified,
you would still parse <code>body</code> of a given size, but instead of
interpreting it with some user type, it will be treated as having no
<code>type</code>, thus yielding a raw byte array. This is super useful, as it
allows you to work on TLV-like formats step-by-step, starting by
supporting only 1 or 2 types of records, and gradually adding more and
more types.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="paragraph">
<p>One needs to make sure that the type used in <code>switch-on</code> and types used
in <code>cases</code> are either identical or at least comparable. For example,
comparing strings against integers will yield a compile-time error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">strz</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span>
      <span class="tok-nt">switch-on</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
      <span class="tok-nt">cases</span><span class="tok-p">:</span>
        <span class="tok-nt">1</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_1</span>
        <span class="tok-nt">2</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, <code>rec_type</code> is declared as a string and cases are comparing it to
integers. So, the compiler will complain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>/seq/1/type/cases/IntNum(1): can&#39;t compare StrFromBytesType(...) and Int1Type(true)</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can use "_" for the default (else) case which will match every
other value which was not listed explicitly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span>    <span class="tok-nt">type</span><span class="tok-p">:</span>
      <span class="tok-nt">switch-on</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
      <span class="tok-nt">cases</span><span class="tok-p">:</span>
        <span class="tok-nt">1</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_1</span>
        <span class="tok-nt">2</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_2</span>
        <span class="tok-nt">_</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_unknown</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Switching types can be a very useful technique. For more advanced
usage examples, see <a href="#switch-advanced">Advanced switching</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_instances_data_beyond_the_sequence">4.12. Instances: data beyond the sequence</h3>
<div class="paragraph">
<p>So far we&#8217;ve done all the data specifications in <code>seq</code> — thus they&#8217;ll
get parsed immediately from the beginning of the stream, one-by-one, in
strict sequence. But what if the data you want is located at some other
position in the file, or comes not in sequence?</p>
</div>
<div class="paragraph">
<p>"Instances" are Kaitai Struct&#8217;s answer for that. They&#8217;re specified
in a key <code>instances</code> on the same level as <code>seq</code>. Consider this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">big_file</span>
  <span class="tok-nt">endian</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">le</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">some_integer</span><span class="tok-p">:</span>
    <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x400000</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-nt">a_string</span><span class="tok-p">:</span>
    <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x500fff</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x11</span>
    <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ASCII</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Inside <code>instances</code> we need to create a map: keys in that map are
attribute names, and values specify attribute in the very same manner as
we would have done it in <code>seq</code>, but there is one important additional
feature: using <code>pos: &#8230;&#8203;</code> one can specify a position to start parsing
that attribute from (in bytes from the beginning of the stream). Just as
in <code>size</code>, one may use expression language and reference other
attributes in <code>pos</code>. This is used very often to allow accessing a file
body inside a container file when we have some file index data: file
position in container and length:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_name</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">8 + 3</span>
    <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ASCII</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_offset</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_size</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">body</span><span class="tok-p">:</span>
    <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_offset</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_size</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another very important difference between the <code>seq</code> attribute and the
<code>instances</code> attribute is that instances are lazy by default. What does
that mean? Unless someone would call that <code>body</code> getter method
programmatically, no actual parsing of <code>body</code> would be done. This is
super useful for parsing larger files, such as images of filesystems. It
is impractical for a filesystem user to load all the filesystem data
into memory at once: one usually finds a file by its name (traversing a
file index somehow), and then can access file&#8217;s <code>body</code> right away. If
that&#8217;s the first time this file is being accessed, <code>body</code> will be loaded
(and parsed) into RAM. Second and all subsequent times will just return
a cached copy from the RAM, avoiding any unnecessary re-loading /
re-parsing, thus conserving both RAM and CPU time.</p>
</div>
<div class="paragraph">
<p>Note that from the programming point of view (from the target
programming languages and from internal Kaitai Struct&#8217;s expression
language), <code>seq</code> attributes and <code>instances</code> are exactly the same.</p>
</div>
</div>
<div class="sect2">
<h3 id="_value_instances">4.13. Value instances</h3>
<div class="paragraph">
<p>Sometimes, it is useful to transform the data (using expression
language) and store it as a named value. There&#8217;s another sort of
instances for that — value instances. They&#8217;re very
simple to use, there&#8217;s only one key in it — <code>value</code> — that specifies an
expression to calculate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">length_in_feet</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">f8</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">length_in_m</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">length_in_feet * 0.3048</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Value instances do no actual parsing, and thus do not require a <code>pos</code>
key or a <code>type</code> key (the type will be derived automatically). If you need
to enforce the type of the expression, see <a href="#typecast">typecasting</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bit_sized_integers">4.14. Bit-sized integers</h3>
<div class="paragraph">
<p>Quite a few protocols and file formats, especially those which aim to
conserve space, pack multiple integers into one byte, using integer
sizes less than 8 bits. For example, an IPv4 packet starts with a byte
that packs both a version number and header length:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>76543210
vvvvllll
  │   │
  │   └─ header length
  └───── version</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s possible to unpack bit-packed integers using old-school
methods with bitwise operations in value instances:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">packed_1</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">version</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">(packed_1 &amp; 0b11110000) &gt;&gt; 4</span>
  <span class="tok-nt">len_header</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span>  <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">packed_1 &amp; 0b00001111</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, Kaitai Struct offers a better way to do it — using
<strong>bit-sized integers</strong>.</p>
</div>
<div class="sect3">
<h4 id="bit-ints-be">4.14.1. Big-endian order</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Feature available since v0.6.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here&#8217;s how the above IPv4 example can be parsed with Kaitai Struct:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">bit-endian</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">be</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">version</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_header</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the <code>meta/bit-endian</code> key, we specify <strong>big-endian</strong> bit field order
(see <a href="#bit-endian">Specifying bit endianness</a> for more info). In this mode, Kaitai Struct starts parsing bit
fields from the most significant bit (MSB, 7) to the least significant bit
(LSB, 0). In this case, "version" comes first and "len_header" second.</p>
</div>
<div class="paragraph">
<p>The bit layout for the above example looks like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>             d[0]
7   6   5   4   3   2   1   0
v3  v2  v1  v0  h3  h2  h1  h0
───────┬──────  ───────┬──────
    version       len_header</pre>
</div>
</div>
<div class="paragraph">
<p><code>d[0]</code> is the first byte of the stream, and the numbers 7-0 on the line
below indicate the invididual bits of this byte (listed from MSB <code>7</code> to LSB <code>0</code>).</p>
</div>
<div class="paragraph">
<p>The value of <code>version</code> can be retrieved as <code>0b{v3}{v2}{v1}{v0}</code>
<em>(<code>0b&#8230;&#8203;</code> is the binary integer literal as present in many programming
languages, and <code>{v3}</code> is the value <code>0</code> or <code>1</code> of the corresponding bit)</em>,
and the <code>len_header</code> value can be retrieved as <code>0b{h3}{h2}{h1}{h0}</code>.</p>
</div>
<div class="paragraph">
<p>Using <code>type: bX</code> (where <code>X</code> is a number of bits to read) is very
versatile and can be used to read byte-unaligned data. A more complex
example of packing, where value spans two bytes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>               d[0]                              d[1]
  7   6   5   4   3   2   1   0     7   6   5   4   3   2   1   0
  a4  a3  a2  a1  a0  b8  b7  b6    b5  b4  b3  b2  b1  b0  c1  c0
  ─────────┬────────  ─────────────────┬──────────────────  ───┬──
           a                           b                       c
 │ ───────────────────────────&gt; │  │ ───────────────────────────&gt; │
        parsing direction       ╷  ↑
                                └┄┄┘</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">bit-endian</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">be</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">a</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b5</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b9</span>
    <span class="tok-c1"># 3 bits (b{8-6}) + 6 bits (b{5-0})</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">c</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b2</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Why is this order of bit field members called "big-endian"? Because
the parsing results are equivalent to first reading a packed
integer in <em>big-endian</em> byte order and then extracting the values
using bitwise operators (<code>&amp;</code> and <code>&gt;&gt;</code>) in a sequential order.
Here&#8217;s the above example rewritten using this conventional approach:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">packed</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u2be</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">a</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">(packed &amp; 0b11111000_00000000) &gt;&gt; (3 + 8)</span>
  <span class="tok-nt">b</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">(packed &amp; 0b00000111_11111100) &gt;&gt; 2</span>
  <span class="tok-nt">c</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span>  <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">packed &amp; 0b00000000_00000011</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the same logic, little-endian bit integers correspond to
unpacking a <strong>little-endian</strong> integer instead. See <a href="#bit-ints-le">Little-endian order</a>
for more info.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Or it can be used to parse completely unaligned bit streams with
repetitions. In this example, we parse an arbitrary number of 3-bit
values:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>             d[0]     d[1]     d[2]     d[3]
           76543210 76543210 76543210 76543210
           nnnnnnnn 00011122 23334445 55666777 ...
           ________ ‾‾‾___‾‾‾‾___‾‾‾____
               ╷     │  ╷  │   ╷  │   ╷
num_threes ────┘     │  │  │   │  │   │
threes[0]  ──────────┘  │  │   │  │   │
threes[1]  ─────────────┘  │   │  │   │
threes[2]  ────────────────┘   │  │   │
threes[3]  ────────────────────┘  │   │
threes[4]  ───────────────────────┘   │
threes[5]  ───────────────────────────┘
  ...</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">bit-endian</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">be</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_threes</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">threes</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b3</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_thress</span></code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>By default, if you mix "normal" byte-sized integers (i.e. <code>uX</code>,
<code>sX</code>) and bit-sized integers (i.e. <code>bX</code>), byte-sized integers will be
kept byte-aligned. That means if you do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">bit-endian</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">be</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">foo</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b6</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">bar</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>two bytes will get parsed like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    76543210 76543210
    ffffff   bbbbbbbb
    ──┬───   ───┬────
      |         |
foo ──┘         |
bar ────────────┘</pre>
</div>
</div>
<div class="paragraph">
<p>i.e. the two least significant bits of the first byte would be lost and
not parsed due to alignment.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="bit-ints-le">4.14.2. Little-endian order</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Feature available since v0.9.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Most formats using little-endian <em>byte order</em> with packed multi-byte
bit fields (e.g. <a href="//formats.kaitai.io/android_img/">android_img</a>,
<a href="//formats.kaitai.io/rar/">rar</a> or <a href="//formats.kaitai.io/swf/">swf</a>)
assume that such bit fields are unpacked manually using bitwise operators
from a little-endian integer parsed in advance containing the whole bit
field. The bit layout of the field is designed accordingly.</p>
</div>
<div class="paragraph">
<p>For example, consider the following bit field:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">packed</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u2le</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">a</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">(packed &amp; 0b11111000_00000000) &gt;&gt; (3 + 8)</span>
  <span class="tok-nt">b</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">(packed &amp; 0b00000111_11111100) &gt;&gt; 2</span>
  <span class="tok-nt">c</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span>  <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">packed &amp; 0b00000000_00000011</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The expressions for extracting the values look exactly the same as
for the <a href="#bit-ints-be">big-endian order</a>, but the actual bit layout
will be different, because here the <code>packed</code> integer is read
in little-endian (LE) byte order.</p>
</div>
<div class="paragraph">
<p>Given that <code>d</code> is a 2-byte array needed to parse an unsigned 2-byte
integer, the numeric value of a BE integer is
<code>0x{d[0]}{d[1]}</code> <em>(<code>0x&#8230;&#8203;</code> is the hexadecimal integer literal
and <code>{d[0]}</code> is the hex value of byte <code>d[0]</code> as seen in hex dumps,
e.g. <code>02</code> or <code>7f</code>)</em>, whereas the value of a LE integer
would be <code>0x{d[1]}{d[0]}</code>.</p>
</div>
<div class="paragraph">
<p>It follows that if we read a BE integer from a new byte array
<code>[d[1], d[0]]</code> (i.e. <code>d</code> reversed), we&#8217;ll get the same result
as when reading a LE integer from the original <code>d</code> array.</p>
</div>
<div class="paragraph">
<p>Because we&#8217;ve already explained how bit-integers work in
<a href="#bit-ints-be">big-endian order</a>, let&#8217;s repeat this method for the
above bitfield on the byte array <code>d</code> reversed (<code>d[1] d[0]</code>) and then
swap the bytes back to the original order of <code>d</code> (<code>d[0] d[1]</code>):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>               d[1]                              d[0]
  7   6   5   4   3   2   1   0     7   6   5   4   3   2   1   0
  a4  a3  a2  a1  a0  b8  b7  b6    b5  b4  b3  b2  b1  b0  c1  c0
  ──────────────┬───────────────    ───────────────┬──────────────
                └──────────────╷   ╷───────────────┘
                                ╲ ╱
                                 ╳
                                ╱ ╲
                ┌──────────────╵   ╵──────────────┐
               d[0]                              d[1]
  7   6   5   4   3   2   1   0     7   6   5   4   3   2   1   0
  b5  b4  b3  b2  b1  b0  c1  c0    a4  a3  a2  a1  a0  b8  b7  b6
  ──────────┬───────────  ──┬───    ─────────┬────────  ────┬─────
            b               c                a              b
│ &lt;──────────────────────────── │  │ &lt;──────────────────────────── │
╷       parsing direction                                          ↑
└┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈&gt;┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘</pre>
</div>
</div>
<div class="paragraph">
<p>As you can guess from the bit layout, you can&#8217;t use <a href="#bit-ints-be">big-endian
bit integers</a> here without splitting the <code>b</code> value into 2 separate
members.</p>
</div>
<div class="paragraph">
<p>This is because each byte in a <strong>big-endian</strong> bit field is gradually "filled"
with members from the most significant bit (7) to the least significant (0),
and if the current byte is filled up to LSB, the parsing continues on
MSB of next byte. It follows that <code>b</code> really can&#8217;t be represented
with a single attribute using this order, because <code>c</code> and <code>a</code> are standing
in the way.</p>
</div>
<div class="paragraph">
<p>Little-endian bit fields use the reversed parsing direction: bytes are filled
from LSB (0) to MSB (7), and after filling the byte up to MSB, values
overflow to the next byte&#8217;s LSB.</p>
</div>
<div class="paragraph">
<p>For example, the above bit layout can be conveniently represented using
little-endian bit integers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">bit-endian</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">le</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">c</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b2</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b9</span>
    <span class="tok-c1"># 6 bits (b{5-0}) + 3 bits (b{8-6})</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">a</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b5</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the KSY snippet, the bit field members in <code>seq</code>
are listed from the least significant value to the most significant.
If we look at the bit masks of bit field members (which can be
directly used for ANDing <code>&amp;</code> with the 2-byte little-endian unsigned
value), they would be sorted in <strong>ascending</strong> order (starting with
the <em>least significant</em> value):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>c    0b00000000_00000011
b    0b00000111_11111100
a    0b11111000_00000000</pre>
</div>
</div>
<div class="paragraph">
<p>This may seem strange at first, but it&#8217;s actually natural from the
perspective of how little-endian bit fields work, and how they
physically store their members.</p>
</div>
<div class="paragraph">
<p>Thanks to this order, Kaitai Struct <strong>doesn&#8217;t need</strong> to know the byte
size of the whole bitfield in advance <em>(so that its members could
be rearranged at compile-time to match their physical location)</em>,
and it can normally parse the attributes on the run.
It follows that little-endian bit-sized integers can be normally
combined with <code>if</code> conditions and repetitions like any other Kaitai Struct type.</p>
</div>
</div>
<div class="sect3">
<h4 id="bit-endian">4.14.3. Specifying bit endianness</h4>
<div class="paragraph">
<p>The key <code>meta/bit-endian</code> specifies the default parsing direction
(<em>bit endianness</em>) of bit-sized integers. It can only have the
literal value <code>le</code> or <code>be</code> (run-time <a href="#calc-endian">switching</a>
is <strong>not</strong> supported).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Support for <code>meta/bit-endian</code> was added in <strong>v0.9</strong>
(previously only BE direction was supported). To maintain
backward compatibility, the big-endian order (<code>be</code>) is default.</p>
</div>
<div class="paragraph">
<p>However, if you don&#8217;t really need to support pre-0.9 KSC
versions, it&#8217;s recommended to state <code>meta/bit-endian: be</code>
<em>explicitly</em>, because it raises awareness about the existence
of LE bit endianness.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Like <code>meta/endian</code>, <code>meta/bit-endian</code> also applies to <code>bX</code> attributes
in the current type and all subtypes, but it can be overridden
using the <code>le</code>/<code>be</code> suffix (<code>bXle</code>/<code>bXbe</code>) for the individual bit
integers. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">bit-endian</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">le</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">foo</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b2</span> <span class="tok-c1"># little-endian</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">my_subtype</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">bar</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b8</span> <span class="tok-c1"># also little-endian</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">baz</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b16be</span> <span class="tok-c1"># big-endian</span></code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p><em>Big-endian</em> and <em>little-endian</em> bit integers can follow <strong>only on a byte
boundary</strong>. They can&#8217;t share the same byte. Joining them on an
unaligned bit position is <em>undefined behavior</em>, and future versions of KSC will throw
a compile-time error if they detect such a situation.</p>
</div>
<div class="paragraph">
<p>For example, this is <strong>illegal</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">foo</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b4be</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">bar</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">b4le</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ksy-documentation">4.15. Documenting your spec</h3>
<div class="paragraph">
<p>We introduced the <code>doc</code> key <a href="#docstrings">early in this user guide</a> as
a simple way to add docstrings to the attributes. However, it&#8217;s not
only attributes that can be documented. The same <code>doc</code> key can be used
in several different contexts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-p tok-p-Indicator">|</span>
  <span class="tok-no">Documentation for type. Works for top-level types too, in case you</span>
  <span class="tok-no">were wondering.</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">attr_1</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
    <span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">Documentation for sequence attribute.</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">attr_2</span><span class="tok-p">:</span>
    <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x1234</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
    <span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">Documentation for parse instance attribute.</span>
  <span class="tok-nt">attr_3</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">attr_2 + 1</span>
    <span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">Documentation for value instance attribute.</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">some_type</span><span class="tok-p">:</span>
    <span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">Documentation for type as well. Works for inner types too.</span>
<span class="tok-nt">params</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">param_1</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
    <span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-p tok-p-Indicator">|</span>
      <span class="tok-no">Documentation for a parameter. Parameters are a relatively</span>
      <span class="tok-no">advanced topic, see below for the explanations.</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="doc-ref">4.15.1. <code>doc-ref</code></h4>
<div class="paragraph">
<p>The <code>doc</code> key has a "sister" key <code>doc-ref</code>, which can be used to specify
references to original documentation. This is very useful to keep
track of what corresponds to what when transcribing an existing
specification. Everywhere where you can use <code>doc</code>, you can use
<code>doc-ref</code> as well. Depending on the target language, this key would be
rendered as something akin to a "see also" extra paragraph after the
main docstring. For example:</p>
</div>
<table class="tableblock frame-none grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="title">Kaitai Struct</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_record</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
    <span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">Total length of record in bytes.</span>
    <span class="tok-nt">doc-ref</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ISO spec, section 1.2.3</span></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="title">Java</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-cm">/**</span>
<span class="tok-cm"> * Total length of record in bytes.</span>
<span class="tok-cm"> * @see &quot;ISO-9876 spec, section 1.2.3&quot;</span>
<span class="tok-cm"> */</span>
<span class="tok-kd">public</span> <span class="tok-kt">int</span> <span class="tok-nf">lenRecord</span><span class="tok-p">()</span> <span class="tok-p">{</span> <span class="tok-k">return</span> <span class="tok-n">lenRecord</span><span class="tok-p">;</span> <span class="tok-p">}</span></code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Inside <code>doc-ref</code>, one can specify:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Just a user-readable string. Most widely used to reference offline documentation. User would need to find relevant portion of documentation manually.</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">doc-ref</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ISO-9876 spec, section 1.2.3</span></code></pre>
</div>
</div>
</li>
<li>
<p>Just a link. Used when existing documentation has a non-ambiguous,
well defined URL that everyone can refer to, and there&#8217;s nothing
much to add to it.</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">doc-ref</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">https://www.youtube.com/watch?v=dQw4w9WgXcQ</span></code></pre>
</div>
</div>
</li>
<li>
<p>Link + description. Used when adding some extra text information is
beneficial: for example, when a URL is not enough and needs some
comments on how to find relevant info inside the document, or the
document is also accessible through some other means and it&#8217;s useful
to specify both URL and section numbering for those who won&#8217;t be
using the URL. In this case, <code>doc-ref</code> is composed of a URL, then a space,
then a description.</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">doc-ref</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">https://tools.ietf.org/html/rfc2795#section-6.1 RFC2795, 6.1 &quot;SIMIAN Client Requests&quot;</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="orig-id">4.15.2. <code>-orig-id</code></h4>
<div class="paragraph">
<p>When transcribing spec based on some existing implementation, most
likely you won&#8217;t be able to keep exact same spelling of all
identifiers. Kaitai Struct imposes pretty draconian rules on what can
be used as <code>id</code>, and there is a good reason for it: different target
languages have different ideas of what constitutes a good identifier,
so Kaitai Struct had to choose some "middle ground" that yields decent
results when converted to all supported languages' standards.</p>
</div>
<div class="paragraph">
<p>However, in many cases, it might be useful to keep references to how
things were named in original implementation. For that, one can
customarily use <code>-orig-id</code> key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_str_buf</span>
    <span class="tok-nt">-orig-id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">StringBufferSize</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str_buf</span>
    <span class="tok-nt">-orig-id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">StringDataInputBuffer</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_str_buf</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>The Kaitai Struct compiler will just ignore any key that starts with
<code>-</code>, and silently allow it. These kind of keys can be used to store
arbitrary additional information, which can be accessible to external
tools (i.e. other than the compiler). Feel free to add more arbitrary
keys if you need to store extra structured information for some
reason. For example, if you have 2 concurrent existing implementations
in C++ and Java, you can store IDs for both of them for future
reference:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">foo_bar</span>
    <span class="tok-nt">-getter-id-cpp</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">get_foo_bar()</span>
    <span class="tok-nt">-getter-id-java</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">getFooBar()</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="verbose-enums">4.15.3. Verbose enums</h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Feature available since v0.8.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to add some documentation for enums, this is possible
using verbose enums declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">enums</span><span class="tok-p">:</span>
  <span class="tok-nt">ip_protocol</span><span class="tok-p">:</span>
    <span class="tok-nt">1</span><span class="tok-p">:</span>
      <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">icmp</span>
      <span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">Internet Control Message Protocol</span>
      <span class="tok-nt">doc-ref</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">https://www.ietf.org/rfc/rfc792</span>
    <span class="tok-nt">6</span><span class="tok-p">:</span>
      <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">tcp</span>
      <span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">Transmission Control Protocol</span>
      <span class="tok-nt">doc-ref</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">https://www.ietf.org/rfc/rfc793</span>
    <span class="tok-nt">17</span><span class="tok-p">:</span>
      <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">udp</span>
      <span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">User Datagram Protocol</span>
      <span class="tok-nt">doc-ref</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">https://www.ietf.org/rfc/rfc768</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this format, instead of specifying just the identifier for every
numeric value, you specify a YAML map, which has an <code>id</code> key for
the identifier, and allows other regular keys (like <code>doc</code> and <code>doc-ref</code>)
to specify documentation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="meta">4.16. Meta section</h3>
<div class="paragraph">
<p>The <code>meta</code> key is used to define a section which stores meta-information
about a given type, i.e. various complimentary stuff, such as titles,
descriptions, pointers to external linked resources, etc:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code></p>
</li>
<li>
<p><code>title</code></p>
</li>
<li>
<p><code>application</code></p>
</li>
<li>
<p><code>file-extension</code></p>
</li>
<li>
<p><code>xref</code> — used to specify <a href="#meta-xref">cross-references</a></p>
</li>
<li>
<p><code>license</code></p>
</li>
<li>
<p><code>tags</code></p>
</li>
<li>
<p><code>ks-version</code></p>
</li>
<li>
<p><code>ks-debug</code></p>
</li>
<li>
<p><code>ks-opaque-types</code></p>
</li>
<li>
<p><code>imports</code></p>
</li>
<li>
<p><code>encoding</code></p>
</li>
<li>
<p><code>endian</code></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
While it&#8217;s technically possible to specify <code>meta</code> keys in
arbitary order (as in any other YAML map), please use the order
recommended in the <a href="ksy_style_guide.html#meta">KSY style guide</a> when
authoring .ksy specs for public use to improve readability.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="meta-xref">4.16.1. Cross-references</h4>
<div class="paragraph">
<p><code>meta/xref</code> can be used to provide arbitrary cross-references for a
particular type in other collections, such as references / IDs in
format databases, wikis, encyclopedias, archives, formal standards,
etc. Syntactically, it&#8217;s just a place where you can store arbitrary
key-value pairs, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">xref</span><span class="tok-p">:</span>
    <span class="tok-nt">forensicswiki</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">Portable_Network_Graphics_(PNG)</span>
    <span class="tok-nt">iso</span><span class="tok-p">:</span> <span class="tok-s">&#39;15948:2004&#39;</span>
    <span class="tok-nt">justsolve</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">PNG</span>
    <span class="tok-nt">loc</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">fdd000153</span>
    <span class="tok-nt">mime</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">image/png</span>
    <span class="tok-nt">pronom</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">fmt/13</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">fmt/12</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">fmt/11</span>
    <span class="tok-nt">rfc</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">2083</span>
    <span class="tok-nt">wikidata</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">Q178051</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are several "well-known" keys used by convention by many spec
authors to provide good cross references of their formats:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>forensicswiki</code> specifies an article name at
<a href="https://forensicswiki.xyz/page/Main_Page">Forensics Wiki</a>, which is a
CC-BY-SA-licensed wiki with information on digital forensics, file
formats and tools. A full link could be generated as
<code><a href="https://forensicswiki.xyz/page/" class="bare">https://forensicswiki.xyz/page/</a></code> + this value.</p>
</li>
<li>
<p><code>iso</code> specifies an ISO/IEC standard number, a reference to a standard
accepted and published by <a href="https://www.iso.org/">ISO</a> (International
Organization for Standardization). Typically these standards are not
available for free (i.e. one has to pay to get a copy of a standard
from ISO), and it&#8217;s non-trivial to link to the ISO standards
catalogue. However, ISO standards typically have clear designations
like "ISO/IEC 15948:2004", so the value should cite everything
except for "ISO/IEC", e.g. <code>15948:2004</code>.</p>
</li>
<li>
<p><code>justsolve</code> specifies an article name at
<a href="http://fileformats.archiveteam.org/wiki/Main_Page">"Just Solve the File Format
Problem" wiki</a>, a wiki that collects information on many file
formats. A full link could be generated as
<code><a href="http://fileformats.archiveteam.org/wiki/" class="bare">http://fileformats.archiveteam.org/wiki/</a></code> + this value.</p>
</li>
<li>
<p><code>loc</code> specifies an identifier in the
<a href="https://www.loc.gov/preservation/digital/formats/fdd/browse_list.shtml">Digital
Formats</a> database of the <a href="https://www.loc.gov/">US Library of Congress</a>, a
major effort to enumerate and document many file formats for digital
preservation purposes. The value typically looks like <code>fddXXXXXX</code>, where
<code>XXXXXX</code> is a 6-digit identifier.</p>
</li>
<li>
<p><code>mime</code> specifies a
<a href="https://en.wikipedia.org/wiki/Media_type">MIME (Multipurpose Internet
Mail Extensions) type</a>, AKA "media type" designation, a string
typically used in various Internet protocols to specify format of
binary payload. As of 2019, there is a
<a href="https://www.iana.org/assignments/media-types/media-types.xhtml">central
registry of media types</a> managed by IANA. The value must specify the full
MIME type (both parts), e.g. <code>image/png</code>.</p>
</li>
<li>
<p><code>pronom</code> specifies a format identifier in the
<a href="https://www.nationalarchives.gov.uk/PRONOM/Default.aspx">PRONOM
Technical Registry</a> of the <a href="https://www.nationalarchives.gov.uk/">UK
National Archives</a>, which is a massive file formats database that
catalogues many file formats for digital preservation
purposes. The value typically looks like <code>fmt/xxx</code>, where <code>xxx</code> is a
number assigned at PRONOM (this idenitifer is called a "PUID", AKA
"PRONOM Unique Identifier" in PRONOM itself). If many different
PRONOM formats correspond to a particular spec, specify them as a YAML
array (see example above).</p>
</li>
<li>
<p><code>rfc</code> specifies a reference to
<a href="https://en.wikipedia.org/wiki/Request_for_Comments">RFC</a>, "Request
for Comments" documents maintained by ISOC (Internet
Society). Despite the confusing name, RFCs are typically treated as
global, Internet-wide standards, and, for example, many networking /
interoperability protocols are specified in RFCs. The value should be
just the raw RFC number, without any prefixes, e.g. <code>1234</code>.</p>
</li>
<li>
<p><code>wikidata</code> specifies an item name at
<a href="https://www.wikidata.org/wiki/Wikidata:Main_Page">Wikidata</a>, a global knowledge base. All
Wikimedia projects (such as language-specific Wikipedias,
Wiktionaries, etc) use Wikidata at least for connecting various
translations of encyclopedic articles on a particular subject, so
keeping just a link to Wikidata is typically enough to.  The value
typically follows a <code>Qxxx</code> pattern, where <code>xxx</code> is a number generated
by Wikidata, e.g. <code>Q535473</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stream">5. Streams and substreams</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Imagine that we&#8217;re dealing with a structure of known size. For the sake of
simplicity, let&#8217;s say that it&#8217;s fixed to exactly 20 bytes (but all the
following is also true if the size is defined by some arbitrarily
complex expression):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">person</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">code</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">name</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">16</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When we&#8217;re invoking user-defined types, we can do either:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">joe</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">person</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>or:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">joe</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">person</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">20</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the subtle difference: we&#8217;ve skipped the <code>size</code> in the first example
and added it in the second one. From the end-user&#8217;s perspective, nothing
has changed. You can still access Joe&#8217;s code and name equally well in
both cases:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-n">r</span><span class="tok-p">.</span><span class="tok-na">joe</span><span class="tok-p">().</span><span class="tok-na">code</span><span class="tok-p">()</span> <span class="tok-c1">// works</span>
<span class="tok-n">r</span><span class="tok-p">.</span><span class="tok-na">joe</span><span class="tok-p">().</span><span class="tok-na">name</span><span class="tok-p">()</span> <span class="tok-c1">// works</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, what gets changed under the hood? It turns out that
specifying <code>size</code> actually brings some new features: if you modify the
<code>person</code> type to be less than 20 bytes long, it still reserves exactly
20 bytes for <code>joe</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">joe</span>        <span class="tok-c1"># reads from position 0</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">person</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">20</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">foo</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>       <span class="tok-c1"># reads from position 20</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">person</span><span class="tok-p">:</span> <span class="tok-c1"># although this type is 14 bytes long now</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">code</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">name</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">10</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the extra 6 bytes would just be skipped. Alternatively,
if you make <code>person</code> to be more than 20 bytes long, it will
trigger an end-of-stream exception:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">joe</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">person</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">20</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">foo</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">person</span><span class="tok-p">:</span> <span class="tok-c1"># 100 bytes is longer than 20 bytes declared in `size`</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">code</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">name</span> <span class="tok-c1"># will trigger an exception here</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">96</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>How does it work? Let&#8217;s take a look under the hood.</p>
</div>
<div class="paragraph">
<p>Sizeless user type
invocation generates the following parsing code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">joe</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-n">Person</span><span class="tok-p">(</span><span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">_io</span><span class="tok-p">,</span> <span class="tok-k">this</span><span class="tok-p">,</span> <span class="tok-n">_root</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, when we declare the <code>size</code>, things get a little bit more
complicated:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">_raw_joe</span> <span class="tok-o">=</span> <span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">_io</span><span class="tok-p">.</span><span class="tok-na">readBytes</span><span class="tok-p">(</span><span class="tok-mi">20</span><span class="tok-p">);</span>
<span class="tok-n">KaitaiStream</span> <span class="tok-n">_io__raw_joe</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-n">KaitaiStream</span><span class="tok-p">(</span><span class="tok-n">_raw_joe</span><span class="tok-p">);</span>
<span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">joe</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-n">Person</span><span class="tok-p">(</span><span class="tok-n">_io__raw_joe</span><span class="tok-p">,</span> <span class="tok-k">this</span><span class="tok-p">,</span> <span class="tok-n">_root</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Every class that Kaitai Struct generates carries a concept of a "stream", usually
available as an <code>_io</code> member. This is the default stream it reads from
and writes to. This stream works just as you might expect from a
regular IO stream implementation in a typical language: it
encapsulates reading from files and memory, stores a pointer to its
current position, and allows reading/writing of various primitives.</p>
</div>
<div class="paragraph">
<p>Declaring a new user-defined type in the middle of the <code>seq</code> attributes
generates a new object (usually via a constructor call), and this object,
in turn, needs its own IO stream. So, what are our options here?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the "sizeless" case, we just pass the current <code>_io</code> along to the new
object. This "reuses" the existing stream with all its properties:
current pointer position, size, available bytes, etc.</p>
</li>
<li>
<p>In the "sized" case, we know the size a priori and want the object we
created to be limited within that size. So, instead of passing an
existing stream, we create a new substream that will be
shorter and will contain the exact number of bytes requested.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Implementations vary from language to language, but, for example, in
Java, the following is done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-c1">// First, we read as many bytes as needed from our current IO stream.</span>
<span class="tok-c1">// Note that if we don&#39;t even have 20 bytes right now, this will throw</span>
<span class="tok-c1">// an EOS exception on this line, and the user type won&#39;t even be invoked.</span>
<span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">_raw_joe</span> <span class="tok-o">=</span> <span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">_io</span><span class="tok-p">.</span><span class="tok-na">readBytes</span><span class="tok-p">(</span><span class="tok-mi">20</span><span class="tok-p">);</span>

<span class="tok-c1">// Second, we wrap our bytes into a new stream, a substream</span>
<span class="tok-n">KaitaiStream</span> <span class="tok-n">_io__raw_joe</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-n">KaitaiStream</span><span class="tok-p">(</span><span class="tok-n">_raw_joe</span><span class="tok-p">);</span>

<span class="tok-c1">// Finally, we pass our substream to the Person class instead of</span>
<span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">joe</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-n">Person</span><span class="tok-p">(</span><span class="tok-n">_io__raw_joe</span><span class="tok-p">,</span> <span class="tok-k">this</span><span class="tok-p">,</span> <span class="tok-n">_root</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>After that, parsing of a <code>person</code> type will be totally bound to the limits
of that particular substream. Nothing in the Person class
can do a thing to the original stream — it just doesn&#8217;t have access to
that object.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s check out a few use cases that demonstrate how powerful this
practice can be.</p>
</div>
<div class="sect2">
<h3 id="_limiting_total_size_of_structure">5.1. Limiting total size of structure</h3>
<div class="paragraph">
<p>Quite often binary formats use the following technique:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First comes some integer that declares the total size of the structure
(or the structure&#8217;s body, i.e. everything minus this header).</p>
</li>
<li>
<p>Then comes the structure&#8217;s body, which is expected to have exactly the
declared number of bytes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body_len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>

  <span class="tok-c1"># The following must be exactly `body_len` bytes long</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">uuid</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">16</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">name</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">24</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">price</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-c1"># This &quot;comment&quot; entry must fill up all remaining bytes up to the</span>
  <span class="tok-c1"># total of `body_len`.</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">comment</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">???</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, one can derive this manually:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>body_len = sizeof(uuid) + sizeof(name) + sizeof(price) + sizeof(comment)</p>
</li>
<li>
<p>body_len = 16 + 24 + 4 + sizeof(comment)</p>
</li>
<li>
<p>sizeof(comment) = body_len - (16 + 24 + 4)</p>
</li>
<li>
<p>sizeof(comment) = body_len - 44</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span>  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">comment</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body_len - 44</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But this is very inconvenient and potentially error prone. What will
happen if at some time in future the record contents are updated
and we forget to update this formula?</p>
</div>
<div class="paragraph">
<p>It turns out that substreams offer a much cleaner solution here. Let&#8217;s
separate our "header" and "body" into two distinct user types, and
then we can just specify <code>size</code> on this <code>body</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body_len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">record_body</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body_len</span>
    <span class="tok-c1"># ^^ This is where substream magic kicks in</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">record_body</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">uuid</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">16</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">name</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">24</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">price</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">comment</span>
        <span class="tok-nt">size-eos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For <code>comment</code>, we just made its size to be up until the end of
stream. Given that we&#8217;ve limited it to the substream in the first
place, this is exactly what we wanted.</p>
</div>
</div>
<div class="sect2">
<h3 id="repeat-until-size-limit">5.2. Repeating until total size reaches limit</h3>
<div class="paragraph">
<p>The same technique might be useful for repetitions as well. If you
have an array of same-type entries, and a format declares the total size
of all entries combined, again, you can try to do this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">total_len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">entries</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">entry</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">???</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And do some derivations to calculate number of entries,
i.e. "total_len / sizeof(entry)". But, again, this is bad because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You need to keep remembering to update this "sizeof" value when
the entry size updates.</p>
</li>
<li>
<p>If the entry size if not fixed, you&#8217;re totally out of luck here.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Solving it using substreams is much more elegant. You just create a
substream limited to <code>total_len</code> bytes, and then use <code>repeat: eos</code> to
repeat until the end of that stream.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="paragraph">
<p>However, note that one&#8217;s naïve approach might not work:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When we&#8217;re dealing with an array of elements, <code>size</code> will refer to
the size of one particular element of the array.</p>
</li>
<li>
<p>Any repetition (and this includes <code>repeat: eos</code>) parses the elements
using the current IO stream. If <code>size</code> is specified, substreams
are created individually for each object inside the loop.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So this is <strong>wrong</strong> (<code>total_len</code> determines the size
of each individual <code>entry</code> substream here):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">total_len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">entries</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">entry</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">total_len</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">eos</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information, see <a href="#keys-repeated">Keys relating to the whole array and to each element in repeated attributes</a>.</p>
</div>
<div class="paragraph">
<p>The proper solution is to add an extra layer of types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">total_len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">entries</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_entries</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">total_len</span>
    <span class="tok-c1"># ^^ here we added the limit and created a single substream</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">file_entries</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">entries</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">entry</span>
        <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">eos</span>
        <span class="tok-c1"># ^^ repeats until the end of that limited substream</span>
  <span class="tok-nt">entry</span><span class="tok-p">:</span>
    <span class="tok-c1"># ...</span>
    <span class="tok-c1"># Now, this can even be of variable size: that&#39;s totally ok.</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_relative_positioning">5.3. Relative positioning</h3>
<div class="paragraph">
<p>Another useful feature that&#8217;s possible with substreams is the fact that
while you&#8217;re in a substream, the <code>pos</code> key works in the context of that
substream as well. That means it addresses data relative to the start of that
substream:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">some_header</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">20</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">80</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">block</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">foo</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-nt">instances</span><span class="tok-p">:</span>
      <span class="tok-nt">some_bytes_in_the_middle</span><span class="tok-p">:</span>
        <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">30</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">16</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, <code>body</code> allocates a substream spanning from 20th byte
(inclusive) till 100th byte (exclusive). Then, in that stream:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>foo</code> would be parsed right from the beginning of that substream,
thus taking up bytes <code>[20..24)</code></p>
</li>
<li>
<p><code>some_bytes_in_the_middle</code> would start parsing 16 bytes from the 30th
byte <strong>of that substream</strong>, thus parsing bytes <code>[20 + 30 .. 20 + 46)</code> =
<code>[50..66)</code> in the main stream.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This comes super handy if your format&#8217;s internal structures somehow
specify offsets relative to some other structures of the format. For
example, a typical filesystem/database often uses a concept of blocks,
and offsets that address stuff inside the current block. Note how KSY with
substreams is easier to read, more concise and less error-prone:</p>
</div>
<table class="tableblock frame-none grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="title">Bad (w/o substream)</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_block</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">some_block</span><span class="tok-p">:</span>
    <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">12345 * len_block</span>
    <span class="tok-c1"># no size =&gt; no substream!</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">data_block</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">data_block</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_data</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u2</span>
    <span class="tok-nt">instances</span><span class="tok-p">:</span>
      <span class="tok-nt">data</span><span class="tok-p">:</span>
        <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">12345 * _root.len_block + ofs_data</span>
        <span class="tok-c1"># have to calculate position manually</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">40</span></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="title">Good (w/substream)</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_block</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">some_block</span><span class="tok-p">:</span>
    <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">12345 * len_block</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_block</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">data_block</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">data_block</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_data</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u2</span>
    <span class="tok-nt">instances</span><span class="tok-p">:</span>
      <span class="tok-nt">data</span><span class="tok-p">:</span>
        <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_data</span>
        <span class="tok-c1"># relative to data_block</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">40</span></code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The more levels of structure offset nesting there are, the more
complicated these <code>pos</code> expressions would get without substreams.</p>
</div>
</div>
<div class="sect2">
<h3 id="_absolute_positioning">5.4. Absolute positioning</h3>
<div class="paragraph">
<p>If you ever need to "escape" the limitations of a substream by
wishing to use a <code>pos</code> key of a parse instance to address something absolutely
(i.e. in the main stream), it&#8217;s easy to do so by adding an <code>io</code> key to
choose the root&#8217;s stream:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">some_header</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">20</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">files</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">80</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_entry</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">eos</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">file_entry</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_name</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">strz</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_body</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_body</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-nt">instances</span><span class="tok-p">:</span>
      <span class="tok-nt">body</span><span class="tok-p">:</span>
        <span class="tok-nt">io</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_root._io</span>
        <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_body</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_body</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s the typical situation encountered in many file container
formats. Here we have a list of <code>files</code>, and each of its entries has
been limited to exactly 80 bytes. Inside each 80-byte chunk, there&#8217;s a
<code>file_name</code>, and, more importantly, a pointer to the absolute location of
the file&#8217;s body inside the stream. The <code>body</code> instance allows us to get that
file&#8217;s body contents quickly and easily. Note that if there was no
<code>io: _root._io</code> key there, that <code>body</code> would have been parsed inside a
80-byte substream (and most likely that would result in an exception
trying to read outside of the 80 byte limit), and that&#8217;s not what we want
here.</p>
</div>
</div>
<div class="sect2">
<h3 id="_choosing_a_substream">5.5. Choosing a substream</h3>
<div class="paragraph">
<p>The technique above is not limited to just the root
object&#8217;s stream. You can address any other object&#8217;s stream as well,
for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">global_header</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">1024</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block_one</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">big_container</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">4096</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block_two</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">smaller_container</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">1024</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">big_container</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">some_header</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">8</span>
      <span class="tok-c1"># the rest of the data in this container would be referenced</span>
      <span class="tok-c1"># from other blocks</span>
  <span class="tok-nt">smaller_container</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_in_big</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_in_big</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-nt">instances</span><span class="tok-p">:</span>
      <span class="tok-nt">something_in_big</span><span class="tok-p">:</span>
        <span class="tok-nt">io</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_root.block_one._io</span>
        <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_in_big</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_in_big</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="process">5.6. Processing: dealing with compressed, obfuscated and encrypted data</h3>
<div class="paragraph">
<p>Some formats obscure the data fully or partially with techniques like
compression, obfuscation or encryption. In these cases, incoming data
should be pre-processed before actual parsing takes place, or we&#8217;ll
just end up with garbage getting parsed. All such pre-processing
algorithms have one thing in common: they&#8217;re done by some function that
takes a stream of bytes and returns another stream of bytes (note that the number
of incoming and resulting bytes might be different, especially in the case
of decompression). While it might be possible to do such transformation
in a declarative manner, it is usually impractical to do so.</p>
</div>
<div class="paragraph">
<p>Kaitai Struct allows you to plug-in some predefined "processing" algorithms
to do decompression, de-obfuscation and decryption to get a
clear stream, ready to be parsed. Consider parsing a file, in which the
main body is obfuscated by applying XOR with 0xaa for every byte:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body_len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body_len</span>
    <span class="tok-nt">process</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">xor(0xaa)</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">some_body_type</span> <span class="tok-c1"># defined normally later</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Applying <code>process: &#8230;&#8203;</code> is available only to raw byte arrays or user
types.</p>
</li>
<li>
<p>One might use expression language inside <code>xor(&#8230;&#8203;)</code>, thus referencing
the XOR obfuscation key read into some other field
previously.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_expression_language">6. Expression language</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Expression language is a powerful internal tool inside Kaitai
Struct. In a nutshell, it is a simple object-oriented, statically-typed
language that gets translated/compiled (AKA "transpiled") into any
supported target programming language.</p>
</div>
<div class="paragraph">
<p>The language is designed to follow the principle of least surprise, so
it borrows tons of elements from other popular languages, like C,
Java, C#, Ruby, Python, JavaScript, Scala, etc.</p>
</div>
<div class="sect2">
<h3 id="_basic_data_types">6.1. Basic data types</h3>
<div class="paragraph">
<p>Expression language operates on the following primitive data types:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Attribute specs</th>
<th class="tableblock halign-left valign-top">Literals</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type: uX</code>, <code>type: sX</code>, <code>type: bX</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1234</code>, <code>-789</code>, <code>0xfc08</code>, <code>0b1101</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Floating point numbers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type: fX</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>123.0</code>, <code>-456.78</code>, <code>4.1607804e+72</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Booleans</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type: b1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code>, <code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Byte arrays</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size: XXX</code>, <code>size-eos: true</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>[0x20, 65, 66, 67]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Strings</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type: str</code>, <code>type: strz</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'foo bar'</code>, <code>"baz\nqux"</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enums</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(<code>type: uX</code> or <code>type: sX</code>) and <code>enum: XXX</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>opcode::jmp</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Streams</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Integers</strong> come from <code>uX</code>, <code>sX</code>, <code>bX</code> type specifications in sequence
or instance attributes (i.e. <code>u1</code>, <code>u4le</code>, <code>s8</code>, <code>b3</code>, etc), or can be
specified literally. One can use:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>decimal form (e.g. <code>123</code>)</p>
</li>
<li>
<p>hexadecimal form using <code>0x</code> prefix (e.g. <code>0xcafe</code> — both upper case and lower case letters are legal, i.e. <code>0XcAfE</code> or <code>0xCAfe</code> will do as well)</p>
</li>
<li>
<p>binary form using <code>0b</code> prefix (e.g. <code>0b00111011</code>)</p>
</li>
<li>
<p>octal form using <code>0o</code> prefix (e.g. <code>0o755</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It&#8217;s possible to use <code>_</code> as a visual separator in literals — it will
be completely ignored by the parser. This could be useful, for example,
to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>visually separate thousands in decimal numbers: <code>123_456_789</code></p>
</li>
<li>
<p>show individual bytes/words in hex: <code>0x1234_5678_abcd</code></p>
</li>
<li>
<p>show nibbles/bytes in binary: <code>0b1101_0111</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Floating point numbers</strong> also follow the normal notation used in the vast
majority of languages: <code>123.456</code> will work, as well as exponential
notation: <code>123.456e-55</code>. Use <code>123.0</code> to enforce floating point type to
an otherwise integer literal.</p>
</div>
<div class="paragraph">
<p><strong>Booleans</strong> can be specified as literal <code>true</code> and <code>false</code> values as in
most languages, but also can be derived by using <code>type: b1</code>. This
method parses a single bit from a stream and represents it as a
boolean value: 0 becomes false, 1 becomes true. This is very useful to
parse flag bitfields, as you can omit <code>flag_foo != 0</code> syntax and just
use something more concise, such as <code>is_foo</code>.</p>
</div>
<div class="paragraph">
<p><strong>Byte arrays</strong> are defined in the attribute syntax when you don&#8217;t
specify anything as <code>type</code>. The size of a byte array is thus determined
using <code>size</code>, <code>size-eos</code> or <code>terminator</code>, one of which is mandatory in
this case. Byte array literals use typical array syntax like the one
used in Python, Ruby and JavaScript: i.e. <code>[1, 2, 3]</code>. There is a
little catch here: the same syntax is used for "true" arrays of
objects (see below), so if you try to do stuff like <code>[1, 1000, 5]</code>
(<code>1000</code> obviously won&#8217;t fit in a byte), you won&#8217;t get a byte array,
you&#8217;ll get an array of integers instead.</p>
</div>
<div class="paragraph">
<p><strong>Strings</strong> normally come from using <code>type: str</code> (or <code>type: strz</code>, which
is a shortcut that implicitly adds <code>terminator: 0</code>).
Literal strings can be specified using double quotes or single
quotes. The meaning of single and double quotes is similar to those of
Ruby, PHP and Shell script:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Single quoted strings are interpreted literally, i.e. backslash <code>\</code>,
double quotes <code>"</code> and other possible special symbols carry no
special meaning, they would be just considered a part of the
string. Everything between single quotes is interpreted literally,
i.e. there is no way one can include a single quote inside a single
quoted string.</p>
</li>
<li>
<p>Double quoted strings support escape sequences and thus allow you to
specify any characters. The supported escape sequences are as
follows:</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 50.0002%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Escape seq</th>
<th class="tableblock halign-left valign-top">Code (dec)</th>
<th class="tableblock halign-left valign-top">Code (hex)</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">bell</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">backspace</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\t</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">horizontal tab</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\n</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xa</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">newline</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\v</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xb</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">vertical tab</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\f</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">form feed</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\r</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">carriage return</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\e</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">27</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x1b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">escape</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\"</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">34</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">double quote</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">39</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x27</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">single quote (technically not required, but supported)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\\</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">92</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x5c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">backslash</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\123</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASCII character with octal code 123; one can specify 1..3 octal digits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\u12bf</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unicode character with code U+12BF; one must specify exactly 4 hex digits</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
One of the most widely used control characters, ASCII zero
character (code 0) can be specified as <code>\0</code> — exactly as it works in
most languages.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Octal notation is prone to errors: due to its flexible
length, it can swallow decimal digits that appear after the code as
part of octal specification. For example, <code>a\0b</code> is three characters:
<code>a</code>, ASCII zero, <code>b</code>. However, <code>1\02</code> is interpreted as two
characters: <code>1</code> and ASCII code 2, as <code>\02</code> is interpreted as one octal
escape sequence.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>TODO: Enums</p>
</div>
<div class="paragraph">
<p><strong>Streams</strong> are internal objects that track the byte stream that we
parse and the state of parsing (i.e. where the pointer is). There is no
way to declare a stream-type attribute directly by parsing
instructions or specify it as a literal. The typical way to get stream
objects is to query the <code>_io</code> attribute from a user-defined object: that
will give us a stream associated with this particular object.</p>
</div>
</div>
<div class="sect2">
<h3 id="_composite_data_types">6.2. Composite data types</h3>
<div class="paragraph">
<p>There are two composite data types in the expression language
(i.e. data types which include other types as components).</p>
</div>
<div class="sect3">
<h4 id="_user_defined_types">6.2.1. User-defined types</h4>
<div class="paragraph">
<p>User-defined types are the types one defines using <code>.ksy</code> syntax —
i.e. the top-level structure and all substructures defined in the <code>types</code> key.</p>
</div>
<div class="paragraph">
<p>Normally, they are translated into classes (or their closest available
equivalent — i.e. a storage structure with members + access members) in the
target language.</p>
</div>
</div>
<div class="sect3">
<h4 id="_arrays">6.2.2. Arrays</h4>
<div class="paragraph">
<p>Array types are just what one might expect from an all-purpose, generic
array type. Arrays come from either using the repetition syntax
(<code>repeat: &#8230;&#8203;</code>) in an attribute specification, or by specifying a literal
array. In any case, all Kaitai Struct arrays have an underlying data type that they
store, i.e. one can&#8217;t put strings and integers into the same
array. One can do arrays based on any primitive data type or composite
data type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
"True" array types (described in this section) and "byte arrays"
share the same literal syntax and lots of method APIs, but they are
actually very different types. This is done on purpose, because many
target languages use very different types for byte arrays and arrays
of objects for performance reasons.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One can use array literals syntax to declare an array (very similar to
the syntax used in JavaScript, Python and Ruby). Type will be derived
automatically based on the types of values inside brackets, for example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[123, 456, -789]</code> — array of integers</p>
</li>
<li>
<p><code>[123.456, 1.234e+78]</code> — array of floats</p>
</li>
<li>
<p><code>["foo", "bar"]</code> — array of strings</p>
</li>
<li>
<p><code>[true, true, false]</code> — array of booleans</p>
</li>
<li>
<p><code>[a0, a1, b0]</code> — given that <code>a0</code>, <code>a1</code> and <code>b0</code> are all the same
objects of user-defined type <code>some_type</code>, this would be array of
user-defined type <code>some_type</code></p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Mixing multiple different types in a single array literal
would trigger a compile-time error, for example, this is illegal: <code>[1,
"foo"]</code>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operators">6.3. Operators</h3>
<div class="paragraph">
<p>Literals can be connected using operators to make meaningful
expressions. Operators are type-dependent: for example, the <code>+</code>
operator applied to two integers would mean arithmetic addition, while the same operator
applied to two strings would mean string concatenation.</p>
</div>
<div class="sect3">
<h4 id="_arithmetic_operators">6.3.1. Arithmetic operators</h4>
<div class="paragraph">
<p>Can be applied to integers and floats:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a + b</code> — addition</p>
</li>
<li>
<p><code>a - b</code> — subtraction</p>
</li>
<li>
<p><code>a * b</code> — multiplication</p>
</li>
<li>
<p><code>a / b</code> — division</p>
</li>
<li>
<p><code>a % b</code> — modulo; note that it&#8217;s not a remainder: <code>-5 % 3</code> is <code>1</code>,
not <code>-2</code>; the result is undefined for negative <code>b</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If both operands are integers, the result of an arithmetic operation is
an integer, otherwise it is a floating point number. For example, that
means that <code>7 / 2</code> is <code>3</code>, and <code>7 / 2.0</code> is <code>3.5</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Can be applied to strings:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a + b</code> — string concatenation</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_relational_operators">6.3.2. Relational operators</h4>
<div class="paragraph">
<p>Can be applied to integers, floats and strings:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a &lt; b</code> — true if <code>a</code> is strictly less than <code>b</code></p>
</li>
<li>
<p><code>a &lt;= b</code> — true if <code>a</code> is less or equal than <code>b</code></p>
</li>
<li>
<p><code>a &gt; b</code> — true if <code>a</code> is strictly greater than <code>b</code></p>
</li>
<li>
<p><code>a &gt;= b</code> — true if <code>a</code> is greater or equal than <code>b</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Can be applied to integers, floats, strings, booleans and enums (does
proper string value comparison):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a == b</code> — true if <code>a</code> is equal to <code>b</code></p>
</li>
<li>
<p><code>a != b</code> — true if <code>a</code> is not equal to <code>b</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_bitwise_operators">6.3.3. Bitwise operators</h4>
<div class="paragraph">
<p>Can only be applied to integers.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>a &lt;&lt; b</code> — left bitwise shift</p>
</li>
<li>
<p><code>a &gt;&gt; b</code> — right bitwise shift</p>
</li>
<li>
<p><code>a &amp; b</code> — bitwise AND</p>
</li>
<li>
<p><code>a | b</code> — bitwise OR</p>
</li>
<li>
<p><code>a ^ b</code> — bitwise XOR</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_logical_boolean_operators">6.3.4. Logical (boolean) operators</h4>
<div class="paragraph">
<p>Can be only applied to boolean values.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>not x</code> — boolean NOT</p>
</li>
<li>
<p><code>a and b</code> — boolean AND</p>
</li>
<li>
<p><code>a or b</code> — boolean OR</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ternary_if_then_else_operator">6.3.5. Ternary (if-then-else) operator</h4>
<div class="paragraph">
<p>If <code>condition</code> (must be boolean expression) is true, then <code>if_true</code>
value is returned, otherwise <code>if_false</code> value is returned:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-n">condition</span> <span class="tok-o">?</span> <span class="tok-n">if_true</span> <span class="tok-p">:</span> <span class="tok-n">if_false</span>

<span class="tok-c1">// Examples</span>
<span class="tok-n">code</span> <span class="tok-o">==</span> <span class="tok-n">block_type</span><span class="tok-p">::</span><span class="tok-n">int32</span> <span class="tok-o">?</span> <span class="tok-mi">4</span> <span class="tok-p">:</span> <span class="tok-mi">8</span>
<span class="tok-s">&quot;It has a header: &quot;</span> <span class="tok-o">+</span> <span class="tok-p">(</span><span class="tok-n">has_header</span> <span class="tok-o">?</span> <span class="tok-s">&quot;Yes&quot;</span> <span class="tok-p">:</span> <span class="tok-s">&quot;No&quot;</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p><code>if_true</code> and <code>if_false</code> must have compatible types. As some
languages (for example, C++ and, to some extent, Java) do not allow
storage of, for example, strings, integers and byte arrays in the same
variable, it&#8217;s generally a bad idea to do something like <code>foo ? 123 :
"some_string"</code> or <code>foo ? true : [12, 34]</code>.</p>
</div>
<div class="paragraph">
<p>It is acceptable to mix:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>integers of various origins and sizes — it would result in a universal
"one size fits all" integer for a target language</p>
</li>
<li>
<p>integers and floats — it would result in a "one size fits all"
floating point type</p>
</li>
<li>
<p>strings of various origins and encodings</p>
</li>
<li>
<p>booleans of various origins</p>
</li>
<li>
<p>objects of different user-defined types — it would result in a
generic KaitaiStruct object</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="paragraph">
<p>Using the ternary operator inside a KSY file (which must remain a valid YAML
file) might be tricky, as some YAML parsers do not allow colons (<code>:</code>)
inside strings literals. So, trying something like this would fail in
some parsers (namely, it <strong>will</strong> fail using "desktop"
kaitai-struct-compiler running under JVM):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">foo</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">condition ? 4</span> <span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To ensure maximum compatibility, put quotes around such strings, i.e:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">foo</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span> <span class="tok-s">&#39;condition</span><span class="tok-nv"> </span><span class="tok-s">?</span><span class="tok-nv"> </span><span class="tok-s">4</span><span class="tok-nv"> </span><span class="tok-s">:</span><span class="tok-nv"> </span><span class="tok-s">8&#39;</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="methods">6.4. Methods</h3>
<div class="paragraph">
<p>Just about every value in expression language is an object (including
literals), and it&#8217;s possible to call methods on it. The common syntax
to use is <code>obj.method(param1, param2, &#8230;&#8203;)</code>, which can be abbreviated
to <code>obj.method</code> if no parameters are required.</p>
</div>
<div class="paragraph">
<p>Note that when the <code>obj</code> in question is a user-defined type, you can
access all its attributes (both sequence and instances) using the same
<code>obj.attr_name</code> syntax. One can chain that to traverse a
chain of substructures: <code>obj.foo.bar.baz</code> (given that <code>obj</code> is a
user-defined type that has a <code>foo</code> field, which points to a user-defined
type that has a <code>bar</code> field, and so on).</p>
</div>
<div class="paragraph">
<p>There are a few pre-defined methods that form a kind of "standard
library" for expression language.</p>
</div>
<div class="sect3">
<h4 id="int-methods">6.4.1. Integers</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method name</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>to_s</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Converts an integer into a string using decimal representation</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="float-methods">6.4.2. Floating point numbers</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method name</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>to_i</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Truncates a floating point number to an integer</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="bytes-methods">6.4.3. Byte arrays</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method name</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>length</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of bytes in the array</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>to_s(encoding)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Decodes (converts) a byte array encoded using the specified <code>encoding</code> scheme into a string</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="str-methods">6.4.4. Strings</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method name</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>length</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Length of a string in number of characters</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>reverse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reversed version of a string</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>substring(from, to)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Extracts a portion of a string between character at offset <code>from</code> and character at offset <code>to - 1</code> (including <code>from</code>, excluding <code>to</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>to_i</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Converts a string in decimal representation to an integer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>to_i(radix)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Converts a string with a number stored in <code>radix</code> representation (i.e. use <code>16</code> to get hexadecimal representation, use <code>8</code> to get octal, etc) to an integer</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="enum-methods">6.4.5. Enums</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method name</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>to_i</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Converts an enum into the corresponding integer representation</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="bool-methods">6.4.6. Booleans</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method name</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>to_i</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns <code>0</code> if the boolean value is <code>false</code> or <code>1</code> if the boolean value is <code>true</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="usertype-methods">6.4.7. User-defined types</h4>
<div class="paragraph">
<p>All user-defined types can be queried to get attributes (sequence
attributes or instances) by their name. In addition to that, there are
a few pre-defined internal methods (they all start with an underscore
<code>_</code>, so they don&#8217;t clash with regular attribute names):</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method name</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_root</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">User-defined type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Top-level user-defined structure in current file</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_parent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">User-defined type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Structure that produced this particular instance of user-defined type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_io</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stream associated with this object of user-defined type</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_array_types">6.4.8. Array types</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method name</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>first</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array base type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets first element of the array</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>last</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array base type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets last element of the array</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of elements in the array</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>min</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array base type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the minimum element of the array</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>max</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array base type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gets the maximum element of the array</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_streams">6.4.9. Streams</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method name</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>eof</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code> if we&#8217;ve reached end of the stream (no more data can be read from it), <code>false</code> otherwise</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Total size of the stream in bytes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pos</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current position in the stream, in bytes from the beginning of the stream</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_techniques">7. Advanced techniques</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="switch-advanced">7.1. Advanced switching</h3>
<div class="sect3">
<h4 id="_switching_over_strings">7.1.1. Switching over strings</h4>
<div class="paragraph">
<p>One can use type switching over other comparable values,
not just integers. For example, one can switch over a string value. Note
that the left side (key) of a <code>cases</code> map is a full-featured Kaitai Struct expression,
thus all we need is to specify a string. Don&#8217;t forget that there&#8217;s
still YAML syntax that might get in a way, so we effectively need to
quote strings twice: once for Kaitai Struct expression language, and once in the
YAML representation to save these quotes from being interpreted by
a YAML parser, i.e.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">strz</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span>
      <span class="tok-nt">switch-on</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
      <span class="tok-nt">cases</span><span class="tok-p">:</span>
        <span class="tok-s">&#39;&quot;KETCHUP&quot;&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_1</span>
        <span class="tok-s">&#39;&quot;MUSTARD&quot;&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_2</span>
        <span class="tok-s">&#39;&quot;GUACAMOLE&quot;&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If the target language allows switching over strings, it will be rendered
as a <code>switch</code>-style statement, or, if it does not, ksc will fall back to an
<code>if</code>-based rendition.</p>
</div>
</div>
<div class="sect3">
<h4 id="_switching_over_enums">7.1.2. Switching over enums</h4>
<div class="paragraph">
<p>One can switch over enums as well. To match against enum values, you would
have to specify enum literals (i.e. <code>enum_name::some_value</code>). Since
there are colons in them, we&#8217;ll have to use YAML quotes again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u2</span>
    <span class="tok-nt">enum</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">media</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span>
      <span class="tok-nt">switch-on</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
      <span class="tok-nt">cases</span><span class="tok-p">:</span>
        <span class="tok-s">&#39;media::cdrom&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_1</span>
        <span class="tok-s">&#39;media::dvdrom&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_2</span>
        <span class="tok-s">&#39;media::cassette&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_3</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fourcc">7.1.3. FourCC</h4>
<div class="paragraph">
<p>Quite a few formats (like TIFF, RIFF, AVI, etc) use a
"FourCC" to switch over in a typical TLV implementation. "FourCC"
(which stands for "four character code") is essentially a 4-byte
value, which is often made human-readable to aid debugging. It&#8217;s
usually tempting to read a fixed-size string from the stream and match it against a
list of strings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">fourcc</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">4</span>
    <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ASCII</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span>
      <span class="tok-nt">switch-on</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">fourcc</span>
      <span class="tok-nt">cases</span><span class="tok-p">:</span>
        <span class="tok-s">&#39;&quot;RGB2&quot;&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block_rgb2</span>
        <span class="tok-s">&#39;&quot;RLE4&quot;&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block_rle4</span>
        <span class="tok-s">&#39;&quot;RLE8&quot;&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block_rle8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this is generally a bad idea:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reading and matching strings is slow. At least it&#8217;s much slower than
reading a single 4-byte integer (because it often involves multiple
copying of data, encoding checks / conversions, etc). The whole
point of using 4-byte FourCC originally was to provide a fast way to
read it in single operation.</p>
</li>
<li>
<p>It&#8217;s hard to provide an encoding for such a string. Quite a few
formats introduced non-ASCII FourCC values, and, even if all current
values are ASCII-safe, there&#8217;s no guarantee that there would be no
weird values like <code>C6 A2 ED 39</code> in future.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The recommended way to handle FourCC-style types is by using an enum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">fourcc</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4le</span>
    <span class="tok-nt">enum</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">pixel_formats</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span>
      <span class="tok-nt">switch-on</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">fourcc</span>
      <span class="tok-nt">cases</span><span class="tok-p">:</span>
        <span class="tok-s">&#39;pixel_formats::rgb2&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block_rgb2</span>
        <span class="tok-s">&#39;pixel_formats::rle4&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block_rle4</span>
        <span class="tok-s">&#39;pixel_formats::rle8&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block_rle8</span>
<span class="tok-nt">enums</span><span class="tok-p">:</span>
  <span class="tok-nt">pixel_formats</span><span class="tok-p">:</span>
    <span class="tok-nt">0x32424752</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rgb2</span>
    <span class="tok-nt">0x34454C52</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rle4</span>
    <span class="tok-nt">0x38454C52</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rle8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This runs as fast as it was originally intended, and it provides an extra
benefit of allowing more verbose FourCC value descriptions.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="do-nothing">7.2. Do nothing</h3>
<div class="paragraph">
<p>In some rare cases, you need a type that actually does absolutely
nothing. For example, you purposely want to ignore parsing a certain
switch case and avoid running it through the default type, e.g. a situation
like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span>
      <span class="tok-nt">switch-on</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type</span>
      <span class="tok-nt">cases</span><span class="tok-p">:</span>
        <span class="tok-nt">1</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_1</span>
        <span class="tok-nt">2</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_2</span>
        <span class="tok-nt">3</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">dummy</span> <span class="tok-c1"># &lt;= must ignore rec_type=3!</span>
        <span class="tok-nt">_</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">rec_type_others</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is very easy to achieve. Here are a few examples of type
definitions which do nothing when invoked:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-c1"># One can use empty JSON object syntax to avoid specifying any of</span>
  <span class="tok-c1"># `seq`, `instances`, etc, sections.</span>
  <span class="tok-nt">dummy_1</span><span class="tok-p">:</span> <span class="tok-p tok-p-Indicator">{}</span>
  <span class="tok-c1"># One can use explicit doc to note that there&#39;s nothing there.</span>
  <span class="tok-nt">dummy_2</span><span class="tok-p">:</span>
    <span class="tok-nt">doc</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">This type is intentionally left blank.</span>
  <span class="tok-c1"># One can use empty `seq` or `instances` or `types` section, any</span>
  <span class="tok-c1"># other empty sections, or any combination of thereof.</span>
  <span class="tok-nt">dummy_3</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span> <span class="tok-p tok-p-Indicator">[]</span>
    <span class="tok-nt">instances</span><span class="tok-p">:</span> <span class="tok-p tok-p-Indicator">{}</span>
    <span class="tok-nt">types</span><span class="tok-p">:</span> <span class="tok-p tok-p-Indicator">{}</span>
  <span class="tok-c1"># One can use a very explicit notion of the fact that we want to parse 0 bytes.</span>
  <span class="tok-nt">dummy_4</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">no_value</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="delimited-struct-advanced">7.3. Advanced delimited structures</h3>
<div class="paragraph">
<p><a href="#delimited-struct">Delimited structures</a>, having <code>terminator</code>
specified to define a structure of arbitrary size, are pretty common
and useful. However, sometimes you&#8217;re dealing with more advanced
versions of these which require you to fine-tune certain aspects of
delimiting.</p>
</div>
<div class="sect3">
<h4 id="consume-include">7.3.1. Terminator: consume or include?</h4>
<div class="paragraph">
<p>What happens with the terminator byte itself, when you&#8217;re defining a
delimited structure? Normally, terminator is not needed inside your
structure, it&#8217;s an external entity. For example, if you&#8217;re parsing
dot-delimited strings, you don&#8217;t want these strings to contain the
dot:</p>
</div>
<table class="tableblock frame-none grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="title">KSY</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str1</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">terminator</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x2e</span> <span class="tok-c1"># `.`</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str2</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">terminator</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x2e</span> <span class="tok-c1"># `.`</span></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="literalblock">
<div class="title">Input and output</div>
<div class="content">
<pre>66 6f 6f 2e 62 61 72 2e = "foo.bar."

str1 = "foo"
str2 = "bar"</pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>But sometimes you indeed want that dot, and it should be part of the
output. This is possible by specifying <code>include: true</code>
(the default is false):</p>
</div>
<table class="tableblock frame-none grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="title">KSY</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str1</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">terminator</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x2e</span> <span class="tok-c1"># `.`</span>
    <span class="tok-nt">include</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">true</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str2</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">terminator</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x2e</span> <span class="tok-c1"># `.`</span>
    <span class="tok-nt">include</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">true</span></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="literalblock">
<div class="title">Input and output</div>
<div class="content">
<pre>66 6f 6f 2e 62 61 72 2e = "foo.bar."

str1 = "foo."
str2 = "bar."</pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Or sometimes your terminator is actually part of a following structure,
and you don&#8217;t want it to be consumed — you want the next structure to
start with that terminator byte. This is possible with
<code>consume: false</code> (which is true by default):</p>
</div>
<table class="tableblock frame-none grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="title">KSY</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str1</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">terminator</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x2e</span> <span class="tok-c1"># `.`</span>
    <span class="tok-nt">consume</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">false</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">the_rest</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">size-eos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">true</span></code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="literalblock">
<div class="title">Input and output</div>
<div class="content">
<pre>66 6f 6f 2e 62 61 72 2e = "foo.bar."

str1 = "foo"
the_rest = ".bar."</pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="eos-error">7.3.2. Ignoring errors in delimited structures</h4>
<div class="paragraph">
<p>Delimited structures actually can be pretty scary: if we read until
the terminator is encountered, what will happen if we never find
one? In raw C, a typical answer is a "segmentation fault" occurring in
the operation that deals with such strings due to runaway reads past
the buffer, i.e. a very bad thing and a big security hole.</p>
</div>
<div class="paragraph">
<p>In Kaitai Struct, however, you can control this behavior. By default,
if you parse a structure awaiting a terminator, and that
terminator never happens, you&#8217;ll get a clear error / exception similar
to "attempted to read past end of stream".</p>
</div>
<div class="paragraph">
<p>In some cases, you
really want to read until the end of the stream, and this should be
considered normal encoding, not an error. For these cases, you can
specify <code>eos-error: false</code> (the default is <code>true</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_string</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
    <span class="tok-nt">terminator</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0</span>
    <span class="tok-nt">eos-error</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">false</span>
    <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">UTF-8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This structure will read both terminated and non-terminated strings
successfully, without triggering an error:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>61 62 63 00 64 65 66 =&gt; my_string = "abc"
61 62 63 00          =&gt; my_string = "abc"
61 62 63             =&gt; my_string = "abc"</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="meta-imports">7.4. Importing types from other files</h3>
<div class="paragraph">
<p>As your project grows in complexity, you might want to have multiple
.ksy files: for example, for different file formats, structures,
substructures, or to reuse the same subformat in several places. As in most
programming languages, Kaitai Struct allows you to have multiple
source files and has <code>imports</code> functionality for that.</p>
</div>
<div class="paragraph">
<p>Using multiple files is very easy. For example, if you have a
<code>date.ksy</code> file that describes the date structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">date</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">year</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u2le</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">month</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u2le</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">day</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u2le</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>and you want to use it in a file listing specification
<code>filelist.ksy</code>, here&#8217;s how to do that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">filelist</span>
  <span class="tok-c1"># this will import &quot;date.ksy&quot;</span>
  <span class="tok-nt">imports</span><span class="tok-p">:</span>
    <span class="tok-p tok-p-Indicator">-</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">date</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">entries</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">entry</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">eos</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">entry</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">filename</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">strz</span>
        <span class="tok-nt">encoding</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ASCII</span>
      <span class="tok-c1"># just use &quot;date&quot; type from date.ksy as if it was declared in</span>
      <span class="tok-c1"># current file</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">timestamp</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">date</span>
      <span class="tok-c1"># you can access its members too!</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">historical_data</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">160</span>
        <span class="tok-nt">if</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">timestamp.year &lt; 1970</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Generally, you just add an array in <code>meta/imports</code> and list all you
want to import there. There are 2 ways to address the files:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Relative</dt>
<dd>
<p>Uses a path given as a relative path to the file, starting with the same
directory in which the main .ksy file resides. This is useful to include files in
the same directory or to navigate to somewhere in your
project. Examples include: <code>foo</code>, <code>foo/bar</code>, <code>../foo/bar/baz</code>, etc.</p>
</dd>
<dt class="hdlist1">Absolute</dt>
<dd>
<p>Looks like <code>/foo</code> or <code>/foo/bar</code> (i.e. starting with a slash), and
searches for the given .ksy file in module search path(s). This is
usually used for modules from centralized repositories / ksy
libraries. Module search paths are determined by (in order of
decreasing priority):</p>
<div class="ulist">
<ul>
<li>
<p>Paths given using the command-line <code>-I</code> switch.</p>
</li>
<li>
<p>Paths given using a <code>KSPATH</code> environment variable (multiple paths
can be specified separated with <code>:</code> on Linux/OS X and with <code>;</code> on
Windows)</p>
</li>
<li>
<p>Default platform-dependent search paths, determined at compiler
build time and/or during installation</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
In the Web IDE you obviously don&#8217;t have environment variables and command-line
  switches, so absolute path imports are used to reference modules in the
  preloaded "kaitai.io" library.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Please use only forward slashes <code>/</code> in import paths for
consistency. Kaitai Struct will convert them automatically to the proper
platform-dependent path separator (<code>/</code> or <code>\</code>).
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="opaque-types">7.5. Opaque types: plugging in external code</h3>
<div class="paragraph">
<p>Sometimes you want Kaitai Struct-generated code to call code in your
application to do the parsing, for example, to parse some text- or
state-based format. For that, you can instruct ksc to generate code
with so-called "opaque" types.</p>
</div>
<div class="paragraph">
<p>Normally, if the compiler encounters a type which is not declared either
in the current file or in one of the imported files, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">doc_container</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">doc</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">custom_encrypted_object</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>... it will output an error:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/seq/0: unable to find type 'custom_encrypted_object', searching from doc_container</pre>
</div>
</div>
<div class="paragraph">
<p>If we want to provide our own implementation of a
<code>custom_encrypted_object</code> type, first we need to compile our .ksy file
with the <code>--opaque-types=true</code> option. This will avoid the error, and the
compiler will consider all unknown types to be "opaque", i.e. it will treat
them as existing in some external space.</p>
</div>
<div class="paragraph">
<p>Alternatively, instead of specifying the command line argument
<code>--opaque-types=true</code> to the compiler, as of Kaitai Struct version 0.7,
it is now possible to specify <code>meta</code> field <code>ks-opaque-types</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">doc_container</span>
  <span class="tok-nt">ks-opaque-types</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">true</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">doc</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">custom_encrypted_object</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Of course, the compiler doesn&#8217;t know anything about opaque types, so
trying to access any attributes of it (i.e. using expression language)
will fail.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This will generate the following code (for example, in Java):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-kd">public</span> <span class="tok-kd">class</span> <span class="tok-nc">DocContainer</span> <span class="tok-kd">extends</span> <span class="tok-n">KaitaiStruct</span> <span class="tok-p">{</span>
    <span class="tok-c1">// ...</span>
    <span class="tok-kd">private</span> <span class="tok-kt">void</span> <span class="tok-nf">_read</span><span class="tok-p">()</span> <span class="tok-p">{</span>
        <span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">doc</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-n">CustomEncryptedObject</span><span class="tok-p">(</span><span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">_io</span><span class="tok-p">);</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you see, <code>CustomEncryptedObject</code> is instantiated here with a single
argument: an IO stream. All that&#8217;s left is to create a class with a
compatible constructor that will allow a call with a single
argument. For statically typed languages, note that the constructor&#8217;s
argument is of type KaitaiStream.</p>
</div>
<div class="paragraph">
<p>An example of what can be done (in Java):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-kd">public</span> <span class="tok-kd">class</span> <span class="tok-nc">CustomEncryptedObject</span> <span class="tok-p">{</span>
    <span class="tok-kt">byte</span><span class="tok-o">[]</span> <span class="tok-n">buf</span><span class="tok-p">;</span>

    <span class="tok-kd">public</span> <span class="tok-nf">CustomEncryptedObject</span><span class="tok-p">(</span><span class="tok-n">KaitaiStream</span> <span class="tok-n">io</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-c1">// read all remaining bytes into our buffer</span>
        <span class="tok-n">buf</span> <span class="tok-o">=</span> <span class="tok-n">io</span><span class="tok-p">.</span><span class="tok-na">readBytesFull</span><span class="tok-p">();</span>

        <span class="tok-c1">// implement our custom super Caesar&#39;s cipher</span>
        <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">i</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-n">buf</span><span class="tok-p">.</span><span class="tok-na">length</span><span class="tok-p">;</span> <span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-kt">byte</span> <span class="tok-n">b</span> <span class="tok-o">=</span> <span class="tok-n">buf</span><span class="tok-o">[</span><span class="tok-n">i</span><span class="tok-o">]</span><span class="tok-p">;</span>
            <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">b</span> <span class="tok-o">&gt;=</span> <span class="tok-sc">&#39;A&#39;</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">b</span> <span class="tok-o">&lt;=</span> <span class="tok-sc">&#39;Z&#39;</span><span class="tok-p">)</span> <span class="tok-p">{</span>
                <span class="tok-kt">int</span> <span class="tok-n">letter</span> <span class="tok-o">=</span> <span class="tok-n">b</span> <span class="tok-o">-</span> <span class="tok-sc">&#39;A&#39;</span><span class="tok-p">;</span>
                <span class="tok-n">letter</span> <span class="tok-o">=</span> <span class="tok-p">(</span><span class="tok-n">letter</span> <span class="tok-o">+</span> <span class="tok-mi">7</span><span class="tok-p">)</span> <span class="tok-o">%</span> <span class="tok-mi">26</span><span class="tok-p">;</span>
                <span class="tok-n">buf</span><span class="tok-o">[</span><span class="tok-n">i</span><span class="tok-o">]</span> <span class="tok-o">=</span> <span class="tok-p">(</span><span class="tok-kt">byte</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-n">letter</span> <span class="tok-o">+</span> <span class="tok-sc">&#39;A&#39;</span><span class="tok-p">);</span>
            <span class="tok-p">}</span>
        <span class="tok-p">}</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Alternatively, opaque types can be (ab)used to connect several
Kaitai Struct-generated types together without importing. If one type
instantiates another, but does not use it in any other way (i.e. doesn&#8217;t
access its inner attributes using expression language), one can just
compile two .ksy files separately, throw them into the same project
and they shall use each other without a problem.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="custom-process">7.6. Custom processing routines</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Feature available since v0.8.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As discussed in <a href="#process">Processing: dealing with compressed, obfuscated and encrypted data</a>, Kaitai Struct utilizes the <code>process</code> key to
invoke processing of the data for the purposes of "bytes in - bytes
out" transformations. It is meant to be used to implement compression &amp;
decompression, encryption &amp; decryption, obfuscation &amp; de-obfuscation,
those kind of transformations.</p>
</div>
<div class="paragraph">
<p>Kaitai Struct runtime libraries come bundled with a "standard" set of
such transformations, but quite often one encounters the need to
implement some custom data transformation algorithm. There are many
thousands of encryption and compression algorithms. It&#8217;s impractical
to both try to implement them in declarative form using standard
Kaitai Struct types (because as an end-user, you&#8217;re most likely
interested in the decoded result, not internal structures of the
algorithm/cipher), and it&#8217;s next to impossible to bundle all the data
processing algorithms in the world into Kaitai Struct runtime (not
only it would become <strong>very</strong> bloated, but also quite a few such
algorithms are encumbered by software patents and licensing
restrictions).</p>
</div>
<div class="paragraph">
<p>To alleviate this problem, Kaitai Struct allows one to invoke custom
processing algorithms, implemented in imperative code in target
languages. This works very similar to <a href="#opaque-types">opaque external
types</a>, but for <code>process</code> invocations, not for <code>type</code>
invocations.</p>
</div>
<div class="paragraph">
<p>Calling a custom process type is easy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">key</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">s4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">buf</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">50</span>
    <span class="tok-nt">process</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_custom_processor(key)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This would generate something like this (example is for Java, other
target languages a use similar technique):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-c1">// Reads 50 bytes to process.</span>
<span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">_raw_buf</span> <span class="tok-o">=</span> <span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">_io</span><span class="tok-p">.</span><span class="tok-na">readBytes</span><span class="tok-p">(</span><span class="tok-mi">50</span><span class="tok-p">);</span>

<span class="tok-c1">// Initializes processor object, passing every argument specified in</span>
<span class="tok-c1">// `process` key into constructor</span>
<span class="tok-n">MyCustomProcessor</span> <span class="tok-n">_process__raw_buf</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-n">MyCustomProcessor</span><span class="tok-p">(</span><span class="tok-n">key</span><span class="tok-p">());</span>

<span class="tok-c1">// Invokes `decode(...)` method, passing unprocessed byte array,</span>
<span class="tok-c1">// expecting it to return a processed one.</span>
<span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">buf</span> <span class="tok-o">=</span> <span class="tok-n">_process__raw_buf</span><span class="tok-p">.</span><span class="tok-na">decode</span><span class="tok-p">(</span><span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">_raw_buf</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A typical implementation of a custom processor would look like this
(again, example in Java; refer to language-specific notes for
documentation on other languages):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-kn">import</span> <span class="tok-nn">io.kaitai.struct.CustomDecoder</span><span class="tok-p">;</span>

<span class="tok-kd">public</span> <span class="tok-kd">class</span> <span class="tok-nc">MyCustomProcessor</span> <span class="tok-kd">implements</span> <span class="tok-n">CustomDecoder</span> <span class="tok-p">{</span>
    <span class="tok-kd">private</span> <span class="tok-kt">int</span> <span class="tok-n">key</span><span class="tok-p">;</span>

    <span class="tok-kd">public</span> <span class="tok-nf">CustomFx</span><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">key</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">key</span> <span class="tok-o">=</span> <span class="tok-n">key</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>

    <span class="tok-nd">@Override</span>
    <span class="tok-kd">public</span> <span class="tok-kt">byte</span><span class="tok-o">[]</span> <span class="tok-nf">decode</span><span class="tok-p">(</span><span class="tok-kt">byte</span><span class="tok-o">[]</span> <span class="tok-n">src</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-c1">// custom &quot;bytes in -&gt; bytes out&quot; processing routine</span>
        <span class="tok-kt">byte</span><span class="tok-o">[]</span> <span class="tok-n">dst</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-kt">byte</span><span class="tok-o">[</span><span class="tok-n">src</span><span class="tok-p">.</span><span class="tok-na">length</span><span class="tok-o">]</span><span class="tok-p">;</span>
        <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">i</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-n">src</span><span class="tok-p">.</span><span class="tok-na">length</span><span class="tok-p">;</span> <span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">)</span> <span class="tok-p">{</span>
           <span class="tok-n">dst</span><span class="tok-o">[</span><span class="tok-n">i</span><span class="tok-o">]</span> <span class="tok-o">=</span> <span class="tok-p">(</span><span class="tok-kt">byte</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-n">src</span><span class="tok-o">[</span><span class="tok-n">i</span><span class="tok-o">]</span> <span class="tok-o">+</span> <span class="tok-n">key</span><span class="tok-p">);</span>
        <span class="tok-p">}</span>

        <span class="tok-k">return</span> <span class="tok-n">dst</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This example is mostly self-explanatory. Strongly typed languages, such
as Java, usually provide some sort of interface that such a custom
processor class should implement. For Java, it&#8217;s named
<code>CustomDecoder</code>. And, as outlined there, we implement:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a custom constructor, which accepts the encoding parameters (like
keys, etc), as specified in a ksy</p>
</li>
<li>
<p>a <code>decode(byte[] src)</code> method which decodes a given byte array — in
this particular example, it just adds whatever we supplied as "key"
to every byte</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>decode</code> can return a different number of bytes than it is
given. This is perfectly normal, for example, with decompression.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, specifying a plain name invokes a custom processing class
in the same namespace/package where the code is generated. If you want
to keep your generated code in a separate namespace/package than your
custom hand-made code, you can specify it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">buf</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">50</span>
    <span class="tok-nt">process</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">com.example.my_rle(5, 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For Java, this would result in an invocation of <code>com.example.MyRle</code>
class. Other languages use similar rules of translation; see
language-specific notes for details.</p>
</div>
<div class="paragraph">
<p>A special namespace prefix "kaitai." is reserved for extended
libraries provided by the Kaitai project. As of 0.8, none of these have been
published, but in future you can expect implementations like
"kaitai.crypto.aes" or "kaitai.compress.lzma" to be provided by
libraries implemented in multiple languages that would be released
along with the minimal core Kaitai Struct runtime.</p>
</div>
</div>
<div class="sect2">
<h3 id="_enforcing_parent_type">7.7. Enforcing parent type</h3>
<div class="paragraph">
<p>Every object (except for the top-level object) in a .ksy file has a
parent, and that parent has a type, which is some sort of user-defined
type. What happens if two or more objects use the same type?</p>
</div>
<div class="imageblock right">
<div class="content">
<img src="svg/two_parents.svg" alt="two parents">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">opcode_jmp</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">target</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">arg</span>
  <span class="tok-nt">opcode_push</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">value</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">arg</span>
  <span class="tok-nt">arg</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">arg_type</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">arg_value</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, both opcodes use same type <code>arg</code>. Given that these
are different types, Kaitai Struct infers that the only thing they have in common
is that they are objects generated by Kaitai Struct, and thus they
usually implement KaitaiStruct API, so the best common type that will
be ok for both parents is <code>KaitaiStruct</code>. Here&#8217;s how it looks in any
statically-typed language, e.g. in Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-kd">public</span> <span class="tok-kd">static</span> <span class="tok-kd">class</span> <span class="tok-nc">OpcodeJmp</span> <span class="tok-kd">extends</span> <span class="tok-n">KaitaiStruct</span> <span class="tok-p">{</span>
    <span class="tok-c1">// ...</span>
    <span class="tok-kd">private</span> <span class="tok-kt">void</span> <span class="tok-nf">_read</span><span class="tok-p">()</span> <span class="tok-p">{</span>
        <span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">target</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-n">Arg</span><span class="tok-p">(</span><span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">_io</span><span class="tok-p">,</span> <span class="tok-k">this</span><span class="tok-p">,</span> <span class="tok-n">_root</span><span class="tok-p">);</span>
    <span class="tok-p">}</span>
    <span class="tok-c1">// ...</span>
<span class="tok-p">}</span>
<span class="tok-kd">public</span> <span class="tok-kd">static</span> <span class="tok-kd">class</span> <span class="tok-nc">OpcodePush</span> <span class="tok-kd">extends</span> <span class="tok-n">KaitaiStruct</span> <span class="tok-p">{</span>
    <span class="tok-c1">// ...</span>
    <span class="tok-kd">private</span> <span class="tok-kt">void</span> <span class="tok-nf">_read</span><span class="tok-p">()</span> <span class="tok-p">{</span>
        <span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">value</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-n">Arg</span><span class="tok-p">(</span><span class="tok-k">this</span><span class="tok-p">.</span><span class="tok-na">_io</span><span class="tok-p">,</span> <span class="tok-k">this</span><span class="tok-p">,</span> <span class="tok-n">_root</span><span class="tok-p">);</span>
    <span class="tok-p">}</span>
    <span class="tok-c1">// ...</span>
<span class="tok-p">}</span>
<span class="tok-kd">public</span> <span class="tok-kd">static</span> <span class="tok-kd">class</span> <span class="tok-nc">Arg</span> <span class="tok-kd">extends</span> <span class="tok-n">KaitaiStruct</span> <span class="tok-p">{</span>
    <span class="tok-kd">public</span> <span class="tok-nf">Arg</span><span class="tok-p">(</span><span class="tok-n">KaitaiStream</span> <span class="tok-n">_io</span><span class="tok-p">,</span> <span class="tok-n">KaitaiStruct</span> <span class="tok-n">_parent</span><span class="tok-p">,</span> <span class="tok-n">TopLevelClass</span> <span class="tok-n">_root</span><span class="tok-p">)</span> <span class="tok-p">{</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that both <code>OpcodeJmp</code> and <code>OpcodePush</code> supply <code>this</code> as <code>_parent</code>
argument in <code>Arg</code> constructor, and, as it is declared as
<code>KaitaiStruct</code>. As both opcode classes are declared with <code>extends
KaitaiStruct</code>, this code will compile properly.</p>
</div>
<div class="sect3">
<h4 id="_replacing_parent">7.7.1. Replacing parent</h4>
<div class="paragraph">
<p>In some situations, you might want to replace the default <code>this</code>
passed as <code>_parent</code> with something else. In some situations this will
provide you a clean and elegant solution to relatively complex
problems. Consider the following data structure that loosely
represents a binary tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">tree</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">chunk_size</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">root_node</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">node</span>
  <span class="tok-nt">node</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">chunk</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">???</span> <span class="tok-c1"># &lt;= need to reference chunk_size from tree type here</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">has_left_child</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">has_right_child</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">left_child</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">node</span>
        <span class="tok-nt">if</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">has_left_child != 0</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">right_child</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">node</span>
        <span class="tok-nt">if</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">has_right_child != 0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Everything is pretty simple here. The main <code>tree</code> type has <code>chunk_size</code>
and a <code>root_node</code>, which is of <code>node</code> type. Each individual <code>node</code> of
this tree carries a chunk of information (of a size determined in the <code>tree</code>
type), some flags (<code>has_left_child</code> and <code>has_right_child</code>) and then
calls itself again to parse either left or right child nodes for the
current node if they exist, according to the flags.</p>
</div>
<div class="paragraph">
<p>The only problem is how to access <code>chunk_size</code> in each node. You can&#8217;t
access the tree object starting from <code>_root</code> here, as there could be many
different trees in our file, and you need to access the current one. Using
<code>_parent</code> directly is just impossible. True, given that <code>node</code> type is
used both by <code>tree</code> and <code>node</code> itself, it got two different parents,
so Kaitai Struct compiler downgrades node&#8217;s parent type to
KaitaiStruct, thus trying to access <code>_parent.chunk_size</code> would result
in a compile-time error.</p>
</div>
<div class="paragraph">
<p>TODO: add more about the error</p>
</div>
<div class="paragraph">
<p>This situation can be resolved easily by using parent overriding. We
modify our code this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">tree</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">chunk_size</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">root_node</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">node</span>
  <span class="tok-nt">node</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">chunk</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_parent.chunk_size</span> <span class="tok-c1"># &lt;= now one can access `tree` with _parent</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">has_left_child</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">has_right_child</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">left_child</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">node</span>
        <span class="tok-nt">parent</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_parent</span> <span class="tok-c1"># &lt;= override parent to be be parent&#39;s parent</span>
        <span class="tok-nt">if</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">has_left_child != 0</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">right_child</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">node</span>
        <span class="tok-nt">parent</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_parent</span> <span class="tok-c1"># &lt;= override parent here too</span>
        <span class="tok-nt">if</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">has_right_child != 0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve changed only three lines. We&#8217;ve enforced the parent of the node in the
<code>left_child</code> and <code>right_child</code> attributes to be passed as <code>_parent</code>,
not <code>this</code>. This, effectively, continues passing a reference to the original
node&#8217;s parent, which is a <code>tree</code> type object, over and over in the whole
recursive structure. This way one can access the structure&#8217;s root by just
using <code>_parent</code>. Naturally, we&#8217;ve done exactly that to get ourselves
<code>chunk_size</code> by just using <code>size: _parent.chunk_size</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_omitting_parent">7.7.2. Omitting parent</h4>
<div class="paragraph">
<p>In some cases, you want some object to have no parent
at all. The primary use case for this is to make sure that some
instantiation of it does not affect the parent type. In many cases, resorting
to this method is a sign that you need to stop and rethink your
design, but for some formats, it&#8217;s unavoidable and in fact simplifies
things a lot.</p>
</div>
<div class="paragraph">
<p>To omit parent (i.e. pass a <code>null</code> reference or something similar as a
parent), use <code>parent: false</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Language design explanation: while it might seem logical to specify
<code>parent: null</code>, there are two catches:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>KSY is a YAML-based language, and YAML treats <code>parent: null</code> as
literally a null value, i.e. totally the same as <code>parent:</code>. So, just
to allow passing solitary <code>null</code> as a value, you&#8217;d need to wrap
it into quotes: <code>parent: 'null'</code>. This would be very awkward for
beginners, as we can&#8217;t even generate a good error message here, as
we can&#8217;t distinguish these two.</p>
</li>
<li>
<p>Omitting parent is actually a special case, not just a matter of
passing <code>null</code>. In fact, some languages do not have a concept of
null, or do not allow passing null as an object reference, so we
need to treat it distinctly anyway, and emphasize that.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>TODO: an example where omitting the parent comes useful</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="typecast">7.8. Typecasting</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Feature available since v0.7.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Kaitai Struct always tries its best to infer all the types
automatically, but in some cases it would be impossible to do so in
compile-time. For example, there could be some extra conditions known
to the format developer, but not to Kaitai Struct.</p>
</div>
<div class="paragraph">
<p>Consider this example — a typical image format, implemented as
<a href="#tlv">Typical TLV implementation (switching types on an expression)</a>, which includes a variable number of self-describing sections:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_sections</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">sections</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">section</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_sections</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">section</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">sect_type</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span>
          <span class="tok-nt">switch-on</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">sect_type</span>
          <span class="tok-nt">cases</span><span class="tok-p">:</span>
            <span class="tok-nt">1</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">sect_header</span>
            <span class="tok-nt">2</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">sect_color_data</span>
            <span class="tok-c1"># ...</span>
  <span class="tok-nt">sect_header</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">width</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">height</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>After that, a bitmap follows, and its size is to be derived as <code>width
* height</code>, as described in the <code>sect_header</code> section. In addition to that,
we&#8217;re 100% sure (due to format constraints) that the body of <code>sections[7]</code>
is always <code>sect_header</code>. How do we access <code>width</code> and <code>height</code> in it?</p>
</div>
<div class="paragraph">
<p>A naïve solution like this won&#8217;t compile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span>  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">bitmap</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">sections[7].body.width * sections[7].body.height</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>reporting the following error:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/seq/2/size: don't know how to call anything on AnyType</pre>
</div>
</div>
<div class="paragraph">
<p>The reason for that is that from the root type perspective, all section
bodies are alike, and in a strongly typed language, it&#8217;s impossible to
guarantee that <code>sections[7].body</code> would be the type we want, and that
type would have <code>width</code> and <code>height</code> attributes. Not only that, but
actually, given that we&#8217;ve specified a <code>size</code> attribute, a <code>body</code> could
be just a raw byte array, and not even a user type. Thus, Kaitai Struct decided
that it could be <code>AnyType</code> — a type that can include anything.</p>
</div>
<div class="paragraph">
<p>The best solution would be to enforce our knowledge using an explicit
typecast with the <code>.as&lt;&#8230;&#8203;&gt;</code> expression operator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span>  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">bitmap</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">sections[7].body.as&lt;sect_header&gt;.width * sections[7].body.as&lt;sect_header&gt;.height</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To make it prettier, one can extract
<code>sections[7].body.as&lt;sect_header&gt;</code> using a named value instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span>  <span class="tok-c1"># ...</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">bitmap</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">header.width * header.height</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">header</span><span class="tok-p">:</span>
    <span class="tok-nt">value</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">sections[7].body.as&lt;sect_header&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Of course, if our assumption about <code>sections[7]</code> doesn&#8217;t come
true in run time, things will go bad. You can expect most languages to
throw a typecasting exception on a failed casting attempt, but in very
low-level languages, such as C++ with RTTI disabled, this would result
in data accessed using wrong offsets, and that could potentially lead
to a crash / segfault / security problem.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="calc-endian">7.9. Calculated default endianness</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Feature available since v0.8.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Most formats (like <a href="//formats.kaitai.io/zip/">zip</a>,
<a href="//formats.kaitai.io/gif/">gif</a>, and many others) stick to a single
fixed endianness: they always use either big-endian or little-endian
integers. Usually this stems from the architecture where the format was
developed: the format is relatively easy and quick to parse on
its "native" architecture, but requires some extra operations (and
parsing time) on non-native architectures.</p>
</div>
<div class="paragraph">
<p>Some formats (like <a href="//formats.kaitai.io/elf/">ELF</a> or
<a href="//formats.kaitai.io/mach_o/">Mach-O</a>), however, take an alternative
approach: they come in two versions, with big-endian integers and
little-endian integers, and they add some sort of header field that
helps to distinguish between the two.</p>
</div>
<div class="paragraph">
<p>To help in implementing such formats, Kaitai Struct supports the concept of
calculated endianness. Instead of using <code>endian: be</code> or <code>endian: le</code>,
one can use a switch, similar to the one introduced in
<a href="#tlv">Typical TLV implementation (switching types on an expression)</a>. Consider this example of a TIFF file — it begins with either
"II" (0x49, 0x49) to specify little-endian encoding or "MM" (0x4d,
0x4d) to specify big-endian encoding:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">tiff</span>
<span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">indicator</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">2</span> <span class="tok-c1"># first two bytes determines endianness</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">tiff_body</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">tiff_body</span><span class="tok-p">:</span>
    <span class="tok-nt">meta</span><span class="tok-p">:</span>
      <span class="tok-nt">endian</span><span class="tok-p">:</span>
        <span class="tok-nt">switch-on</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_root.indicator</span>
        <span class="tok-nt">cases</span><span class="tok-p">:</span>
          <span class="tok-s">&#39;[0x49,</span><span class="tok-nv"> </span><span class="tok-s">0x49]&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">le</span>
          <span class="tok-s">&#39;[0x4d,</span><span class="tok-nv"> </span><span class="tok-s">0x4d]&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">be</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">version</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u2</span>
      <span class="tok-c1"># ...</span>
    <span class="tok-nt">types</span><span class="tok-p">:</span>
      <span class="tok-nt">ifd</span><span class="tok-p">:</span>
        <span class="tok-c1"># inherits endianness of `tiff_body`</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, <code>version</code> and all other numeric types without forced
endianness would use endianness determined by a switch expression in
<code>meta/endian</code> of <code>tiff_body</code>. Moreover, this determined endianness
would also be propagated to other subtypes, declared within
<code>tiff_body</code>.</p>
</div>
<div class="paragraph">
<p>If <code>indicator</code> is neither <code>II</code> nor <code>MM</code>, i.e. both <code>cases</code> fail,
this example would trigger a parsing exception. If you want to handle
it in a manner like "II means little-endian and everything else means
big-endian", use the normal else case (<code>_</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">meta</span><span class="tok-p">:</span>
  <span class="tok-nt">endian</span><span class="tok-p">:</span>
    <span class="tok-nt">switch-on</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_root.indicator</span>
    <span class="tok-nt">cases</span><span class="tok-p">:</span>
      <span class="tok-s">&#39;[0x49,</span><span class="tok-nv"> </span><span class="tok-s">0x49]&#39;</span><span class="tok-p tok-p-Indicator">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">le</span>
      <span class="tok-nt">_</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">be</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="param-types">7.10. Parametric types</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Feature available since v0.8.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Consider the following format, which features two similar lists of key-value pairs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">short_pairs</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">kv_pair_3</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x100</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">long_pairs</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">kv_pair_8</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x100</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">kv_pair_3</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">key</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">3</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">value</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">strz</span>
  <span class="tok-nt">kv_pair_8</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">key</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">8</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">value</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">strz</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The only difference between <code>kv_pair_3</code> and <code>kv_pair_8</code> types is the
length of <code>key</code>. "Short" pairs use a 3-byte long key, and "long" pairs
use an 8-byte key. That&#8217;s lots of duplication, and just imagine what
would happen if you need 4-byte keys or 6-byte keys. To alleviate
that, one can declare a so-called "parametric" type, like this one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">kv_pair</span><span class="tok-p">:</span>
    <span class="tok-nt">params</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_key</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u2</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">key</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_key</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">str</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">value</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">strz</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>params</code> acts like <code>seq</code>, but instead of reading attributes values
from the stream, these attributes are expected to be passed as
parameters when one invokes this type. This is done by specifying
parameter value in brackets after the type name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">short_pairs</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">kv_pair(3)</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x100</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">long_pairs</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">kv_pair(8)</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0x100</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, there could be more than one parameter (in which case, they
are to be comma-separated), and one can use a variety of types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">my_number</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">fancy_encrypted_number_format(3, true, [0x03, 0xb7, 0x8f])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>type</code> specification in a <code>params</code> definition is slightly different from
normal <code>type</code> specifications in <code>seq</code> or <code>instances</code>. It specifies a pure
concept of "type", as would be used to represent data in a programming
language, without any serialization details (like endianness, sizes,
conversions, encodings, etc). Thus, one can&#8217;t use any extra keys to
specify that, but instead one can use:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>no type or <code>bytes</code> to specify byte arrays</p>
</li>
<li>
<p><code>str</code> to specify strings</p>
</li>
<li>
<p><code>bool</code> to specify booleans</p>
</li>
<li>
<p><code>struct</code> to allow arbitrary KaitaiStruct-compatible user types</p>
</li>
<li>
<p><code>io</code> to specify KaitaiStream-compatible IO streams</p>
</li>
<li>
<p><code>any</code> to allow any type (if the target language supports that)</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Parametric types with mandatory parameters can&#8217;t be read from a
file directly (as they obviously need parameter values supplied from
somewhere), and thus the typical <code>fromFile(&#8230;&#8203;)</code> helper method is not
available for them.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="repeat-index">7.11. Repetition index</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Feature available since v0.8.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For the majority of formats, one doesn&#8217;t need to access a loop iteration
index. If you have a typical archive file directory, which lists file
name, offset of the file body and size of the file body together, just
use the object-oriented approach:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_files</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">files</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_entry</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_files</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">file_entry</span><span class="tok-p">:</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">name</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">strz</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_body</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_body</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-nt">instances</span><span class="tok-p">:</span>
      <span class="tok-nt">body</span><span class="tok-p">:</span>
        <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_body</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_body</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, if your format has some information laid out sparsely, i.e. a
separate table of file sizes and their contents, you can use <code>_index</code>
to access the repetition index and resolve the size from the size array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_files</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_files</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_files</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">files</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_files[_index]</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_files</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If a format specifies file <strong>offsets</strong> and you want to read
the contents of the files present on these offsets, things become
more complicated. You can&#8217;t read all the bodies in a single
instance with repetition, because <code>pos</code> used on a repeated attribute
acts as an offset where to start sequentially reading all the items
(see <a href="#keys-repeated">Keys relating to the whole array and to each element in repeated attributes</a> for more info). So we have to wrap the file
body in an extra user type <code>file_body</code>, where we can do the actual
parsing.</p>
</div>
<div class="paragraph">
<p>However, <code>_index</code> is a "local variable", so we lose access to it
as soon as we enter the subtype <code>file_body</code>. The solution is to
pass <code>_index</code> into <code>file_body</code> using <a href="#param-types">Parametric types</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_files</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-c1"># ...</span>
  <span class="tok-c1"># ... some other data here, might be variable size</span>
  <span class="tok-c1"># ...</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_names</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">strz</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_files</span>
  <span class="tok-c1"># ...</span>
  <span class="tok-c1"># ... some other data here, might be variable size</span>
  <span class="tok-c1"># ...</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">len_files</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_files</span>
  <span class="tok-c1"># ...</span>
  <span class="tok-c1"># ... some other data here, might be variable size</span>
  <span class="tok-c1"># ...</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_files</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_files</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">file_bodies</span><span class="tok-p">:</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_body(_index)</span> <span class="tok-c1"># &lt;= pass `_index` into file_body</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_files</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">file_body</span><span class="tok-p">:</span>
    <span class="tok-nt">params</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">i</span>               <span class="tok-c1"># =&gt; receive `_index` as `i` here</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">s4</span>
    <span class="tok-nt">instances</span><span class="tok-p">:</span>
      <span class="tok-nt">body</span><span class="tok-p">:</span>
        <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_parent.ofs_files[i]</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_parent.len_files[i]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A more extreme example is a format that specifies only start offsets,
but does not directly specify sizes of the files:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>30 00 00 00│70 00 00 00│f0 02 00 00
           │           │
0x30       │0x70       │0x2f0
  └────────────┘└─────────────┘
    file 0        file 1

    start 0x30    start 0x70
    end   0x70    end   0x2f0
    ──────────    ───────────
    size  0x40    size  0x280</pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we have N = 3 offsets, which specify N - 1 = 2
sections. Sizes of the sections must be derived as the start of the
following section minus the start of the current section. To do such
a calculation, we can use <code>_index</code> in the expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_offsets</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-c1"># Just read offsets normally</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_files</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_offsets</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">file_bodies</span><span class="tok-p">:</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_body(_index)</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_offsets - 1</span>
<span class="tok-nt">type</span><span class="tok-p">:</span>
  <span class="tok-nt">file_body</span><span class="tok-p">:</span>
    <span class="tok-nt">params</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">i</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">s4</span>
    <span class="tok-nt">instances</span><span class="tok-p">:</span>
      <span class="tok-nt">body</span><span class="tok-p">:</span>
        <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_parent.ofs_files[i]</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_parent.ofs_files[i + 1] - _parent.ofs_files[i]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In an even more complicated example, we have file names interleaved with
offsets. There are N - 1 file names and N offsets:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>03 00 00 00       = 3 offsets, 2 files
30 00 00 00       = offset 0x30
66 6f 6f 2e 63 00 = "foo.c", null-terminated string
70 00 00 00       = offset 0x70
62 61 72 2e 63 00 = "bar.c", null-terminated string
f0 02 00 00       = offset 0x2f0</pre>
</div>
</div>
<div class="paragraph">
<p>In this case we&#8217;ll need to do a calculation inside <code>file_entry</code>.
Once we pass the <code>_index</code> from the parent type to it, it&#8217;s easy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_offsets</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">first_offset</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">files</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">file_entry(_index)</span> <span class="tok-c1"># &lt;= pass `_index` into file_entry</span>
    <span class="tok-nt">repeat</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">expr</span>
    <span class="tok-nt">repeat-expr</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">num_offsets - 1</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">file_entry</span><span class="tok-p">:</span>
    <span class="tok-nt">params</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">i</span>                <span class="tok-c1"># =&gt; receive `_index` as `i` here</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-nt">seq</span><span class="tok-p">:</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">name</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">strz</span>
      <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_end</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u4</span>
    <span class="tok-nt">instances</span><span class="tok-p">:</span>
      <span class="tok-nt">ofs_start</span><span class="tok-p">:</span>
        <span class="tok-c1"># Normally we access previous file&#39;s end offset and use it as</span>
        <span class="tok-c1"># our current start offset, but for the very first file we&#39;ll</span>
        <span class="tok-c1"># use special field, as &quot;previous file&quot; does not exist for it.</span>
        <span class="tok-nt">value</span><span class="tok-p">:</span> <span class="tok-s">&#39;i</span><span class="tok-nv"> </span><span class="tok-s">&gt;</span><span class="tok-nv"> </span><span class="tok-s">0</span><span class="tok-nv"> </span><span class="tok-s">?</span><span class="tok-nv"> </span><span class="tok-s">_parent.files[i</span><span class="tok-nv"> </span><span class="tok-s">-</span><span class="tok-nv"> </span><span class="tok-s">1].ofs_end</span><span class="tok-nv"> </span><span class="tok-s">:</span><span class="tok-nv"> </span><span class="tok-s">_parent.first_offset&#39;</span>
      <span class="tok-nt">body</span><span class="tok-p">:</span>
        <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_start</span>
        <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">ofs_end - ofs_start</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_common_pitfalls">8. Common pitfalls</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section illustrates problems that are encountered frequently by
beginner Kaitai Struct users.</p>
</div>
<div class="sect2">
<h3 id="_specifying_size_creates_a_substream">8.1. Specifying size creates a substream</h3>
<div class="paragraph">
<p>Specifying <code>size</code> (or <code>size-eos</code>, or <code>terminator</code>) while specifying a
user type creates a substream. This will mean that all offsets (<code>pos:
XXX</code>) inside that user type will be (1) relative to that substream&#8217;s
beginning, (2) constrained to that substream. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">header</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">4</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">4</span> <span class="tok-c1"># &lt;= important size designation, creates a substream</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">byte_3</span><span class="tok-p">:</span>
    <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">3</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span>
<span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">block</span><span class="tok-p">:</span>
    <span class="tok-nt">instances</span><span class="tok-p">:</span>
      <span class="tok-nt">byte_3</span><span class="tok-p">:</span>
        <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">3</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Given input <code>00 01 02 03|04 05 06 07</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>size</code> is present, the main type&#8217;s <code>byte_3</code> will be <code>03</code>, and
<code>block.byte_3</code> will be <code>07</code> (due to its allocation in a substream)</p>
</li>
<li>
<p>If <code>size</code> is absent, the main type&#8217;s <code>byte_3</code> will be <code>03</code>, and
<code>block.byte_3</code> will be <code>03</code> as well (as it will be reusing the root stream)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Avoiding this pitfall is simple: there are two ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Avoid creating a substream when it&#8217;s not needed (i.e. drop the <code>size</code> designation)</p>
</li>
<li>
<p>Force use of a particular stream in a parse instance with <code>io: XXX</code>, e.g.:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">types</span><span class="tok-p">:</span>
  <span class="tok-nt">block</span><span class="tok-p">:</span>
    <span class="tok-nt">instances</span><span class="tok-p">:</span>
      <span class="tok-nt">byte_3</span><span class="tok-p">:</span>
        <span class="tok-nt">io</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">_root._io</span> <span class="tok-c1"># &lt;= thanks to this, always points to a byte in main stream</span>
        <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">3</span>
        <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">u1</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_not_specifying_size_does_not_create_a_substream">8.2. Not specifying size does not create a substream</h3>
<div class="paragraph">
<p>An opposite of the previous pitfall, not specifying <code>size</code> (or <code>size-eos</code>, or <code>terminator</code>)
does not create a substream and thus accessing that element&#8217;s IO will
effectively point to the main stream (and thus will be a no-op). In this
example, the idea is to reparse the <code>block</code> region twice with two different
types <code>type1</code> and <code>type2</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">header</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">strz</span> <span class="tok-c1"># some variable-sized field before `block`</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block_as_type1</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">type1</span>
    <span class="tok-nt">size</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">16</span> <span class="tok-c1"># &lt;= important, creates a substream</span>
<span class="tok-nt">instances</span><span class="tok-p">:</span>
  <span class="tok-nt">block_as_type2</span><span class="tok-p">:</span>
    <span class="tok-nt">io</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">block_as_type1._io</span>
    <span class="tok-nt">pos</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">0</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">type2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If that <code>size</code> is missing, <code>block_as_type2</code> will reuse the main
stream and will parse a piece of data from <code>pos: 0</code>, which would likely
be part of <code>header</code>, not the region occupied by <code>block_as_type1</code>.</p>
</div>
<div class="paragraph">
<p>To avoid this pitfall, always make sure you specify <code>size</code> / <code>size-eos</code> /
<code>terminator</code> when you want a substream to be created.</p>
</div>
</div>
<div class="sect2">
<h3 id="_applying_process_without_a_size">8.3. Applying <code>process</code> without a size</h3>
<div class="paragraph">
<p>In all cases, the size of the data to process must be defined (either with
<code>size: &#8230;&#8203;</code> or with <code>size-eos: true</code>), i.e. this is legal (without
process — size takes will be determined by <code>some_body_type</code>, reading
normally from a stream):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">some_body_type</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And this is not:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="yaml"><span></span><span class="tok-nt">seq</span><span class="tok-p">:</span>
  <span class="tok-p tok-p-Indicator">-</span> <span class="tok-nt">id</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">body</span>
    <span class="tok-nt">process</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">xor(0xaa)</span>
    <span class="tok-nt">type</span><span class="tok-p">:</span> <span class="tok-l tok-l-Scalar tok-l-Scalar-Plain">some_body_type</span>
    <span class="tok-c1"># will not compile — lacks size</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is because most processing algorithms need to know the size of data
to process beforehand, and the final size of <code>some_body_type</code> might be
determined only in run-time, after parsing took place.</p>
</div>
</div>
<div class="sect2">
<h3 id="keys-repeated">8.4. Keys relating to the whole array and to each element in repeated attributes</h3>
<div class="paragraph">
<p>If you use repetition in an attribute, it&#8217;s important to understand
which YAML keys refer to the whole array and which affect the individual
elements instead. Here&#8217;s the list:</p>
</div>
<table class="tableblock frame-none grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<div class="title">Whole array</div>
<ul>
<li>
<p><code>doc</code></p>
</li>
<li>
<p><code>doc-ref</code></p>
</li>
<li>
<p><code>id</code></p>
</li>
<li>
<p><code>if</code></p>
</li>
<li>
<p><code>io</code></p>
</li>
<li>
<p><code>pos</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<div class="title">Individual elements</div>
<ul>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>size-eos</code></p>
</li>
<li>
<p><code>type</code></p>
</li>
<li>
<p><code>enum</code></p>
</li>
<li>
<p><code>contents</code></p>
</li>
<li>
<p><code>pad-right</code></p>
</li>
<li>
<p><code>terminator</code></p>
</li>
<li>
<p><code>include</code></p>
</li>
<li>
<p><code>consume</code></p>
</li>
<li>
<p><code>eos-error</code></p>
</li>
<li>
<p><code>encoding</code></p>
</li>
<li>
<p><code>process</code></p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If you need some key from one group to "belong" to the other, you
have to add an extra user-defined type. Depending on your needs,
it may be necessary to either wrap a single item or the entire
array in it.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>To force a key relating to <strong>individual elements</strong> to apply to the whole
array instead: create a user type that <strong>wraps the entire array</strong>,
and apply the key on the attribute which uses this wrapper type.</p>
<div class="paragraph">
<p>You can see the example in <a href="#repeat-until-size-limit">Repeating until total size reaches limit</a>. There we know
just the <code>size</code> of the entire array, but a <code>size</code> key specified on a field
using repetition would mean the size of each item, so it&#8217;s necessary to add type
<code>file_entries</code> containing the array. Then there&#8217;s no problem to create
a substream of the total size and put this type into it, because keys <code>size</code>
and <code>repeat</code> no longer meet in the same attribute.</p>
</div>
</li>
<li>
<p>To force a key relating to the <strong>entire array</strong> to apply to each
individual item instead: create a user type that <strong>wraps the single element</strong>,
and apply the key on the attribute of this wrapper with the item type itself.</p>
<div class="paragraph">
<p>For instance, the second example in section <a href="#repeat-index">Repetition index</a> shows an archive
file directory with separated file offsets and sizes and we need to read the
actual file bodies. We don&#8217;t want <code>pos</code> to mean the offset of the array, but
the offset of the items, so it&#8217;s necessary to wrap the item in its own type.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
    <div id="footer">
            &copy; 2015&ndash;2023 Kaitai Project
    </div>
    <script src="js/jquery-1.12.3.min.js"></script>
    <script src="js/bootstrap.min.js"></script>

    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-76299550-1', 'auto');
        ga('send', 'pageview');
    </script>
<script src="js/asciidoctor-tabs.js"></script>
</body>
</html>